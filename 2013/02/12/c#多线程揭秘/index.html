<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>C#多线程揭秘 | bystander&#39;s blog</title>
    <meta property="og:title" content="C#多线程揭秘 - bystander&#39;s blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2013-02-12T16:31:22&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2013-02-12T16:31:22&#43;08:00'>
        
    <meta name="Keywords" content="">
    <meta name="description" content="C#多线程揭秘">
        
    <meta name="author" content="bystander">
    <meta property="og:url" content="http://leaver.me/2013/02/12/c#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8F%AD%E7%A7%98/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="http://leaver.me/">
                        bystander&#39;s blog
                    </a>
                
                <p class="description">寻找窄门</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="http://leaver.me/">首页</a>
                    
                    <a  href="http://leaver.me/categories" title="目录">目录</a>
                    
                    <a  href="http://leaver.me/about/" title="关于我">关于我</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">C#多线程揭秘</h1>
        </header>
        <date class="post-meta meta-date">
            2013年2月12日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='http://leaver.me/categories/%E6%88%91%E7%9A%84%E7%BF%BB%E8%AF%91'>我的翻译</a></span>
            
        </div>
        
        
        
        <div class="post-content">
            <p>文章略长。。。
Demo下载：<a href="http://pan.baidu.com/share/link?shareid=290200&amp;uk=1493685990">Demo.Threading.zip</a>
<strong>介绍</strong>
本文将通过一些例子来展示.net 中如何实现多线程，涉及到以下四部分。
1 .线程概念
2 .如何实现多线程
3 .如何确保线程安全
4 .死锁</p>
<p><strong>什么是进程</strong>
一个进程就是一个可执行文件运行的操作系统上下文环境。它被用来分隔虚拟地址空间，线程，对象句柄（指向类似文件这样的资源的指针），以及环境变量，进程还有一些类似优先级类和最大内存分配的属性。</p>
<p>也就是说：
1 .一个进程就是一个包含资源的内存块。
2 .操作系统执行的一个单独的任务。
3 .一个正在运行的软件
4 .一个进程拥有一个/多个操作系统线程</p>
<p>一般的。一个进程最大可以是4GB的内存空间，这块内存是安全，私有，其他进程是无法访问的。</p>
<p><strong>什么是线程</strong>
一个线程就是在一个进程里执行的一条指令流，所有的线程都在一个进程里执行，也就是一个进程可以包含多个线程。线程公用进程的虚拟地址空间。线程是操作系统的调度单元。一个线程的上下文由操作系统进行保存/恢复。
也就是说：
1 .一个线程是进程里的一条指令流。
2 .所有的线程在进程里。一个进程可以有多个线程
3 .一个进程的所有线程使用进程的虚拟地址空间。</p>
<p><strong>什么是多线程</strong>
多线程指的是进程同时有多个线程活动。这可以通过时间片的线程模拟或是多cpu上的超线程来实现。可以提高性能。
<strong>多线程-为什么或是为什么不?</strong>
为什么多线程
1 .保持UI响应。
2 .提高性能(对于cpu密集型和I/O密集型的进程)
为什么不多线程
1 .过度使用降低性能
2 .代码复杂，增加设计时间，潜在的bug</p>
<p>线程池
线程池为你的程序提供了一个由操作系统管理的机制。在线程池里的都是后台线程。一个线程池线程在程序的前台线程都退出后，也会推出。每个进程一个线程池。默认情况下。每个处理器会为进程分配25个线程。但是可以通过SetMaxThreads  方法来改变。</p>
<p><strong>.net 中的线程</strong>
在.net 中，线程可以通过下面6个方法来实现。
1 .Thread线程类
2 .Delegates委托
3 .Background Worker
4 .ThreadPool 线程池
5 .Task任务类
6 .Parallel并行类</p>
<p>下面的几部分里。我将逐一展示实现方法。</p>
<p>简而言之，多线程就是通过使程序同时运行多个任务来最大化计算机能力，同时能够保持UI响应。下图是一个例子的图示。
<a href="http://leaverimage.b0.upaiyun.com/32605_o.jpg"><img src="/images/472b9c05527afb3cb133d1d5689cdca367412bc0.jpg" alt=""></a></p>
<p><strong>代码</strong>
提供的源码是一个简单的WinForm程序。模拟了.net中委托，线程类和Background Worker三种方法。
程序异步执行一个繁重的操作，这样UI就不会无响应。三个方法都是模拟的。
<a href="http://leaverimage.b0.upaiyun.com/32606_o.jpg"><img src="/images/a0567e4556b306284f9d9793d2879ae6716dae23.jpg" alt=""></a></p>
<p>这个“繁重”的操作
真实的开发中，这个繁重的操作从轮询数据库到流媒体操作都可以。基本上可以是任何事情。源码里面是向一个字符串追加值。String是不能变的。追加的时候，新的字符串变量会被创建，旧的会被丢弃，这是由CLR处理的。如果做很多次这个操作，是很耗资源的。这也是为什么我们使用Stringbuilder.Append 来代替这个操作。通过调整界面中的次数。可以通知追加的次数。</p>
<p>后面我们有一个Utility泪，有一个LoadData() 方法。类里面也有一个和LoadData() 有着同样签名的委托</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>同步调用</strong>
当点击Get Data Sync按钮的时候。操作和UI在同一个线程里，因此阻塞了UI线程。因此。UI线程会未响应</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>异步调用</strong>
使用委托（异步编程模型）</p>
<p>如果你选择了“Delegates”单选按钮，那么LoadData()方法就会通过使用委托来异步调用。首先通过utility.LoadData(). 的地址初始化delLoadData  类型，然后调用委托的BeginInvoke()方法。在.net的世界里。任何一个有着BeginXXX和EndXXX名字的方法都是异步的。比如delegate.Invoke()将会在同一个线程里调用方法。而delegate.BeginInvoke()则会另开一个线程调用。
BeginInvoke()有三个参数
1 .传递给Utility.LoadData()方法的参数
2 .回调方法的地址
3 .对象的状态</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>回调</strong>
一旦我们开了一个线程执行一些操作，我们就想知道操作正在发生些什么，换句话说。我们需要当操作完成的时候我们能够收到通知。有三种方法可以知道一个操作是否完成。
1 .回调
2 .轮询
3 .等待直到完成
在我的源码里，我们使用回调方法来捕获线程的完成。回调只需要在调用BeginInvoke的时候把回到函数的名字传递进去。这会告诉线程当你做完工作以后调用这个回调方法就好了。</p>
<p>一旦一个独立线程里的一个方法启动。你也许关心也许不关心方法的返回值，如果一个方法没有返回值，那么可以叫做“触发然后忘记的调用”，这种情况下就不需要回调函数了。这里callback直接传入null就可以了。</p>
<!-- raw HTML omitted -->
<p>在我们的例子中，我们需要一个回调方法，因此，哦们需要传递回调方法的名字到参数里。这里我们的回调方法的名字就叫做CallBack(),纯属巧合。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>回调方法的签名都是void MethodName(IAsyncResult asyncResult).
IAsyncResult包含了关于线程的一些必要的信息，返回的数据可以像下面这样提取。</p>
<!-- raw HTML omitted -->
<p>而轮询的方法（本例没有使用）则是像这样</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>等待直到完成，如名所示，就是等待直到完成。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>更新UI
既然我们已经捕获了操作结束，并且取回了LoadData()的结果。我们需要用结果来更新UI，但是有个问题。文本框需要在UI线程里更新，结果在回调里取到了。回调和他启动的时候是一个线程(他是由新开的线程启动的)。因为UI线程和回调不是同一个线程。换句话说。文本框不能像下面这样更新。</p>
<!-- raw HTML omitted -->
<p>回调里执行这一行将会导致一个跨线程的系统异常。我们需要在后台线程和Ui线程之前构建一个桥。来更新文本框的值。可以通过使用Invoke()或是BeginInvoke()方法。
我定义了一个方法来更新UI</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>对上面的方法定义一个委托</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>如下调用BeginInvoke()方法。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>需要注意的是一旦一个线程通过委托启动。它就不能取消，暂停，或是终止，我们无法控制那个线程。</p>
<p>使用Thread线程类
同样的操作可以是哟哦那个Thread类来完成。这个类的优点是你可以对操作有更多的控制，比如暂停/取消操作，类在System.Threading命名空间里。
我们有一个私有的方法LoadData(),他是Utility.LoadData()方法的一个包装。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>这样做是因为 Utility.LoadData() 需要一个参数。而我们需要一个ThreadStart委托，这个委托没有参数。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>这个委托没有参数，为了防止我们需要传递参数，我们可以使用有参的ThreadStart委托，不幸的是，这个委托只能把object作为参数，而我们需要一个字符串所以需要类型转换。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>是的。Thread泪可以对线程有更多的控制。中断。终止，获取线程状态。
使用BackgroundWorker
这个类是一个组件，可以使得线程使用更简单，这个BackgroundWorker类的主要特点就是可以异步的报告进度，这就可以用来更新状态栏，保持UI可视化的更新进度
为了完成操作，我们需要把下面两个属性设置为true，缺省时false
•	WorkerReportsProgress
•	WorkerSupportsCancel</p>
<p>这个类有三个主要的事件DoCount, ProgressChanged, RunWorkerCompleted 初始化的时候需要注册这三个事件</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>一旦调用，下面的方法就会启动来执行操作。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>CancellationPending  属性用来检查该操作是否被取消。要取消操作，需要调用</p>
<!-- raw HTML omitted -->
<p>下面这行代码报告进度</p>
<!-- raw HTML omitted -->
<p>一旦调用，下面的方法就会被调用，来更新UI</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>最后，操作完成时调用bgCount_RunWorkerCompleted  方法</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Thread Pool线程池</p>
<p>不建议程序员随心所欲创建很多线程，创建线程是很昂贵的操作，有一些额外的调用。同时，每个cpu在一个时间片内只能运行一个建成，如果一个单核系统上有多个线程，计算机一次只能运行一个，因此通过给线程分配时间片来模拟多线程。会产生上下文切换的消费，因此，如果有很多的线程，其中一些什么都不做，保持闲置，那么这些额外的消费会影响性能。因此，程序员对于创建线程应该相当小心</p>
<p>幸运的是，CLR有一个托管的代码库。这就是ThreadPool类，这个类管理一些线程，并且根据我们的程序创建或销毁线程，开始的时候没有线程启动。当需要的时候就会创建，如果我们设置了SetMinThreads属性，一旦开始操作就很快会达到这个值，之后，如果发现有些线程闲置了很长时间，则会决定会杀掉一些线程。
线程池类液允许我们管理一系列的工作项目。这些工作项目会委托到一个后台线程。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>其中heavyOperation定义如下：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>注意WaitCallBack这个委托的签名，需要把一个object作为参数，通常用来在线程间传递状态信息。
注意我们知道委托通过使用ThreadPool来工作。我们必须探索和他一起的回调技术，我们可以使用WaitHandle来捕获回调，WaitHandle派生了两个子类：
**AutoResetEvent 和 ManualResetEvent. **</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>这里有一个Global类，这个类包含WaitHandles的一个单例。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>而WaitOne方法。阻塞了代码执行，直到在后台线程中设置了WaitHandle。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>AutoResetEvent当自动设置以后又重设自己。和高速收费站很类似。多辆车合并，以让一次只有一辆车通过。当一辆车来的时候，门就设置为允许通过，然后又重设为关闭处理下一辆车。
下面的例子详细说明了AutoResetEvent。想一想。我们有一个服务名为DoWork()这个方法就是繁重的操作，我们的程序需要在调用这个方法后更新日志文件。考虑到多个线程异步的访问这个方法。我们必须确保更新日志文件是线程安全的，这样一次只能有一个线程可用。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>我们创建两个线程，同时委托DoWork()方法。然后我们调用UpdateLog()方法。更新日志的代码执行将会等待直到每一个线程都完成各自的工作之后才执行。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>ManualResetEvent 不同于AutoResetEvent，我们需要在再次设置之前手工重置他，他不会自动重置，考虑我们有一个方法是持续在后台线程中发布消息。这个方法持续循环等待信号以发送消息。当值被设置以后，方法就开始发消息。当等待句柄被重置，发送服务停止，然后处理就可以重复进行了。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>任务Task类
.net 4.0 提出了Task，是ThreadPool的扩展，概念相当美好。我们可以取消任务，等待任务。检查进度，考虑下面的例子将要用到的三个方法。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>我们还有三个task用来运行这三个方法。第一个线程完成没有返回结果，第二个线程完成并且返回结果，第三个线程在完成之前取消。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>我们创建8个对象，来模拟并行请求，在一个4核的处理器上，4个请求将会同时进行，其余的则会等待。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>我们可以通过设置MaxDegreeOfParallelism  的值来控制/限制并行任务的数量。如果被设置为-1，就是说没有限制。。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>线程安全</strong>
关于线程常常讨论的一个就是线程安全了。考虑一个被多个线程使用的资源，资源将会以一种不确定的方式被使用，导致结果乱七八糟，这就是我们为什么要实现线程安全的程序，是为了让资源一次只能被一个线程操作，下面是.net中实现线程安全的一些方法。
Interlocked  这个Interlocked类把操作看作是原子的。比如，简单的加减法在处理器内部是分为三步的。当多个线程访问同样的对象进行这些操作的时候，导致结果混乱，一个建成在执行了前两步后，被挂起。另一个线程执行了完整的三步，之后，当第一个线程恢复执行的时候他就覆写了这个值，第二个线程所做的操作就丢失了。因此我们需要看这些操作看作是原子的。使他们能够线程安全的。比如加减，读，交换等等。
System.Threading.Interlocked.Increment(object);</p>
<p>Monitor  这个Monitor类用来锁住那些有可能多线程下有风险的对象。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Locks  这个Locks类是Monitor的加强版，最好的一个例子就就是单例类的GetInstance() 方法，多个线程可以访问这段代码，因此使用一个syncLock对象锁住，这个对象和真实世界的锁很想，如果两个或多个资源都有要是，他们可以打开锁并且访问资源。因此，我们必须确保要是是唯一不共享的。这里就是这个syncLock对象。把这个对象作为私有的变量是很好的。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Reader-Writer Lock  这个锁可以被无限制数量的同时读者请求，或者被一个单一的写者请求，如果大多数是读请求很少/时间很短，那么 比Monitor性能更好。读写者在不同的队列里，当写者拥有锁的时候，读者排队等待写者完成，当读者有锁的时候，所有的写者排队。读者和写者交替着完成工作，下面的代码详细解释了。有两个方法。ReadFromCollection  和WriteToCollection 从一个集合里各自的读/写。注意AcquireReaderLock  和 AcquireWriterLock 的使用</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Mutex   Mutex通常用来在操作系统中共享资源，最好的例子就是检测是否同时有两个同样的进程在运行。</p>
<p><strong>死锁</strong>
当谈论线程安全的时候，死锁是无法逃避的。
死锁是两个/多个线程锁住了同样的资源。都在等待对方释放。会导致操作无休止的等待。死锁可以通过认真的编程避免。比如：
线程A锁住对象A
线程A锁住对象B
线程B锁住对象B
线程B锁住对象A
线程A等待线程B释放对象B，而线程B等待线程A释放对象A，考虑下面的例子。在一个死锁类里，我们有两个方法OperationA和OperationB嵌套的锁住两个对象，同时运行两个方法。会导致死锁。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>工作线程VS I/O线程
操作系统只有一个线程概念，但是.net 对我们抽象出了一层，我们可以处理两个线程-工作线程和I/O线程，ThreadPool.GetAvailableThreads(out workerThread, out ioThread) 这个方法可以返回给我们可用的每种线程的可用数目。当写代码的时候，程序中繁重的任务应该被分为两部分，计算密集型和I/O密集型。计算密集型是那些CPU运转较多，比如运行查询或是复杂的算法的部分。I/O密集型是那些被用来做一些系统I/O硬件或是网络设备的部分。比如-读写文件，从数据库取数据，查询远程web服务器等。计算密集型应该委托给工作线程，I/O密集型应该被委托给I/O线程。如果我们委托工作线程去做I/O密集型的操作，当设备做这个操作的时候，线程会阻塞，阻塞的线程就是浪费的资源，另一方面，如果我们使用I/O线程做同样的任务，调用线程将会委托任务给设备驱动，自己则回到线程池，当操作完成后，调用线程会从线程池中被通知来处理任务完成。有点事线程保持未阻塞来处理其他的任务，因为当调用线程发起了I/O操作以后，就委托给了操作系统的部分。来处理设备驱动。因此就没有理由阻塞线程了。在.net的类库里。有专门的类型处理I/O线程。比如FileStream类里的BeginRead()和EndRead()方法。所有类似的</p>
<p><strong>总结</strong>
能力越大，责任越大 –线程池
1 .没有程序应该在UI线程里做繁重的任务。没有比无响应的UI更难以接受的了。一般情况下，通过使用线程池来管理线程异步执行一些繁重的任务。
2 .UI不能直接在非UI或是后台线程里更新。程序要需要委托这类工作给UI线程。这可以通过在winform里使用Invoke方法。在WPF里使用Dispatcher方法。或是使用BackGroundWorker自动处理。
3 .线程是很昂贵的资源应该被认真对待。“越多越热闹”显然是不能接受的。
4 .在我们的程序里的问题不会通过简单的把工作交给另一个线程就能解决。不会有神奇的事情发生。程序需要被合理的设计。来获得高效率。
5 .通过Thread类来创建县城的时候要万分小心。调整线程优先级应该慎重。又可以导致其他重要的线程不能执行。
6 .胡乱设置IsBackground为false可能会引发无法预料的错误。前台线程直到完成才会让程序终止，如果用户想要终止将程序，结果运行在后台的一个任务被设置为了前台线程。导致程序无法终止了。
7 .多程序中多线程贡献资源的时候，异步线程技术要小心，死锁可以通过认真的编码避免一部分。
8 .程序员应该确保线程不要太多。闲置线程可能增加开销并且导致内存溢出。
9 .I/O操作必须委托给I/O线程而不是工作线程。</p>

        </div>

        


        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/2012/12/24/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/">Lambda高手之路第四部分</a></li>
        
        <li><a href="/2012/12/18/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/">Lambda高手之路第一部分</a></li>
        
        <li><a href="/2012/10/09/c#%E7%BC%96%E5%86%99ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BD%AF%E4%BB%B6/">C#编写FTP客户端软件</a></li>
        
        <li><a href="/2012/10/07/%E6%8E%A5%E5%8F%A3vs-%E5%A7%94%E6%89%98/">接口VS 委托</a></li>
        
        <li><a href="/2012/10/04/%E7%AE%80%E5%8D%95%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/">简单扩展方法增强代码可读性</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='http://leaver.me/tags/c'>C＃</a></li>
                
                <li><a href='http://leaver.me/tags/windows'>windows</a></li>
                
                <li><a href='http://leaver.me/tags/%E5%AD%A6%E4%B9%A0'>学习</a></li>
                
                <li><a href='http://leaver.me/tags/%E7%BF%BB%E8%AF%91'>翻译</a></li>
                
            </ul>
            
        </div>
    </article>
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "leaverme" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
    
</div>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='http://leaver.me/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="http://leaver.me/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="http://leaver.me/2020/01/08/2019-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" title="2019 年终总结">2019 年终总结</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/12/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3raft%E5%8D%8F%E8%AE%AE/" title="深入理解Raft协议">深入理解Raft协议</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/10/27/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E7%AC%94%E8%AE%B0/" title="《非暴力沟通》笔记">《非暴力沟通》笔记</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/10/06/wedding-of-friends/" title="Wedding of Friends">Wedding of Friends</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/09/29/principle-note/" title="Principle Note">Principle Note</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/09/14/%E6%A2%A6%E8%A7%81%E9%B2%B8%E9%B1%BC%E7%9A%84%E9%82%A3%E4%B8%80%E5%A4%9C/" title="梦见鲸鱼的那一夜">梦见鲸鱼的那一夜</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/08/20/understand-hong-kong-2/" title="Understand Hong Kong 2">Understand Hong Kong 2</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/08/18/understand-hong-kong-part-1/" title="Understand Hong Kong Part 1">Understand Hong Kong Part 1</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/07/09/%E9%94%99%E8%BF%87%E7%9A%84%E9%83%BD%E6%98%AF%E5%91%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%89%8D%E6%98%AF%E4%BA%BA%E7%94%9F/" title="错过的都是命，得到的才是人生">错过的都是命，得到的才是人生</a>
    </li>
    
    <li>
        <a href="http://leaver.me/2019/04/06/recently/" title="Recently">Recently</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li><a href="http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记 (186)</a></li>
    
    <li><a href="http://leaver.me/categories/%E6%88%91%E7%9A%84%E7%BF%BB%E8%AF%91/">我的翻译 (57)</a></li>
    
    <li><a href="http://leaver.me/categories/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/">文章收藏 (53)</a></li>
    
    <li><a href="http://leaver.me/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/">生活记录 (3)</a></li>
    
    <li><a href="http://leaver.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记 (4)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="http://leaver.me/tags/android/">android</a>
    
    <a href="http://leaver.me/tags/c/">C＃</a>
    
    <a href="http://leaver.me/tags/c&#43;&#43;/">C&#43;&#43;</a>
    
    <a href="http://leaver.me/tags/java/">java</a>
    
    <a href="http://leaver.me/tags/javascript/">javascript</a>
    
    <a href="http://leaver.me/tags/linux/">linux</a>
    
    <a href="http://leaver.me/tags/mac/">mac</a>
    
    <a href="http://leaver.me/tags/matlab/">matlab</a>
    
    <a href="http://leaver.me/tags/maven/">maven</a>
    
    <a href="http://leaver.me/tags/mysql/">mysql</a>
    
    <a href="http://leaver.me/tags/nextgen-gallery/">NextGEN Gallery</a>
    
    <a href="http://leaver.me/tags/php/">php</a>
    
    <a href="http://leaver.me/tags/python/">python</a>
    
    <a href="http://leaver.me/tags/shell/">shell</a>
    
    <a href="http://leaver.me/tags/spring/">spring</a>
    
    <a href="http://leaver.me/tags/sql/">sql</a>
    
    <a href="http://leaver.me/tags/stackoverflow/">stackoverflow</a>
    
    <a href="http://leaver.me/tags/wcf/">WCF</a>
    
    <a href="http://leaver.me/tags/web/">web</a>
    
    <a href="http://leaver.me/tags/windows/">windows</a>
    
    <a href="http://leaver.me/tags/wordpress/">wordpress</a>
    
    <a href="http://leaver.me/tags/wpf/">WPF</a>
    
    <a href="http://leaver.me/tags/%E4%B8%8A%E6%B5%B7/">上海</a>
    
    <a href="http://leaver.me/tags/%E4%B8%8B%E8%BD%BD/">下载</a>
    
    <a href="http://leaver.me/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
    
    <a href="http://leaver.me/tags/%E4%BA%92%E8%81%94%E7%BD%91/">互联网</a>
    
    <a href="http://leaver.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
    
    <a href="http://leaver.me/tags/%E5%88%B6%E5%BA%A6/">制度</a>
    
    <a href="http://leaver.me/tags/%E5%89%8D%E7%AB%AF/">前端</a>
    
    <a href="http://leaver.me/tags/%E5%8E%9F%E5%88%9B/">原创</a>
    
    <a href="http://leaver.me/tags/%E5%A4%A7%E5%AD%A6/">大学</a>
    
    <a href="http://leaver.me/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
    
    <a href="http://leaver.me/tags/%E5%AE%89%E5%85%A8/">安全</a>
    
    <a href="http://leaver.me/tags/%E5%AE%B6%E5%BA%AD/">家庭</a>
    
    <a href="http://leaver.me/tags/%E5%B7%A5%E4%BD%9C/">工作</a>
    
    <a href="http://leaver.me/tags/%E5%B7%A5%E5%85%B7/">工具</a>
    
    <a href="http://leaver.me/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
    <a href="http://leaver.me/tags/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</a>
    
    <a href="http://leaver.me/tags/%E5%BC%80%E5%8F%91/">开发</a>
    
    <a href="http://leaver.me/tags/%E5%BF%83%E7%90%86/">心理</a>
    
    <a href="http://leaver.me/tags/%E6%80%BB%E7%BB%93/">总结</a>
    
    <a href="http://leaver.me/tags/%E6%8A%80%E6%9C%AF/">技术</a>
    
    <a href="http://leaver.me/tags/%E6%8F%92%E4%BB%B6/">插件</a>
    
    <a href="http://leaver.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    
    <a href="http://leaver.me/tags/%E6%94%B6%E8%97%8F/">收藏</a>
    
    <a href="http://leaver.me/tags/%E6%95%B0%E5%AD%A6/">数学</a>
    
    <a href="http://leaver.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    
    <a href="http://leaver.me/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/">数据挖掘</a>
    
    <a href="http://leaver.me/tags/%E6%96%87%E7%AB%A0/">文章</a>
    
    <a href="http://leaver.me/tags/%E6%99%BA%E8%83%BD/">智能</a>
    
    <a href="http://leaver.me/tags/%E6%9D%82%E6%96%87/">杂文</a>
    
    <a href="http://leaver.me/tags/%E6%AD%A6%E6%B1%89/">武汉</a>
    
    <a href="http://leaver.me/tags/%E6%B1%87%E7%BC%96/">汇编</a>
    
    <a href="http://leaver.me/tags/%E7%88%B1%E6%83%85/">爱情</a>
    
    <a href="http://leaver.me/tags/%E7%90%86%E8%AE%BA/">理论</a>
    
    <a href="http://leaver.me/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/">生产力</a>
    
    <a href="http://leaver.me/tags/%E7%94%9F%E6%B4%BB/">生活</a>
    
    <a href="http://leaver.me/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/">电子书</a>
    
    <a href="http://leaver.me/tags/%E7%94%B5%E5%BD%B1/">电影</a>
    
    <a href="http://leaver.me/tags/%E7%A4%BE%E4%BC%9A/">社会</a>
    
    <a href="http://leaver.me/tags/%E7%A7%91%E6%8A%80/">科技</a>
    
    <a href="http://leaver.me/tags/%E7%AC%94%E8%AE%B0/">笔记</a>
    
    <a href="http://leaver.me/tags/%E7%AE%97%E6%B3%95/">算法</a>
    
    <a href="http://leaver.me/tags/%E7%BC%96%E7%A8%8B/">编程</a>
    
    <a href="http://leaver.me/tags/%E7%BC%96%E8%AF%91/">编译</a>
    
    <a href="http://leaver.me/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
    
    <a href="http://leaver.me/tags/%E8%81%8C%E4%B8%9A/">职业</a>
    
    <a href="http://leaver.me/tags/%E8%AE%B0%E5%BD%95/">记录</a>
    
    <a href="http://leaver.me/tags/%E8%AE%BE%E8%AE%A1/">设计</a>
    
    <a href="http://leaver.me/tags/%E8%AF%BB%E4%B9%A6/">读书</a>
    
    <a href="http://leaver.me/tags/%E8%BD%AF%E4%BB%B6/">软件</a>
    
    <a href="http://leaver.me/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a>
    
    <a href="http://leaver.me/tags/%E8%BF%90%E7%BB%B4/">运维</a>
    
    <a href="http://leaver.me/tags/%E9%87%91%E8%9E%8D/">金融</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://www.cppfans.org/" title="C&#43;&#43;爱好者博客">C&#43;&#43;爱好者博客</a>
        </li>
        
        <li>
            <a target="_blank" href="http://www.kailing.pub" title="KL，每天进步一点点">KL，每天进步一点点</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="http://leaver.me/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div class="container">
        &copy; 2020 <a href="http://leaver.me/">bystander&#39;s blog By bystander</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/flysnow-org/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-30961201-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>






</body>

</html>