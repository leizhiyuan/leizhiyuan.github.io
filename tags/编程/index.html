<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>编程 | bystander's blog</title><meta property="og:title" content="编程 - bystander's blog"><meta property="og:type" content="article"><meta name=Keywords content><meta name=description content="编程"><meta name=author content="bystander"><meta property="og:url" content="http://leaver.me/tags/%E7%BC%96%E7%A8%8B/"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml+xml href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/index.xml title="bystander's blog"><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><a id=logo href=http://leaver.me/>bystander's blog</a><p class=description>寻找窄门</p></div><div><nav id=nav-menu class=clearfix><a href=http://leaver.me/>首页</a>
<a href=http://leaver.me/categories title=目录>目录</a>
<a href=http://leaver.me/about/ title=关于我>关于我</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><h3 class=archive-title>包含标签
<span class=keyword>编程</span>
的文章</h3><article class=post><header><h1 class=post-title><a href=http://leaver.me/2016/11/06/graylog%E4%B8%AD%E7%9A%84mongodb%E9%85%8D%E7%BD%AE/>graylog中的mongodb配置</a></h1></header><date class="post-meta meta-date">2016年11月6日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>接手的一个工具平台,发现 graylog 集群使用了单个的 mongodb 作为数据库,于是需要配置一下集群,来防止数据丢失,毕竟很多配置都在里面.
为了以防万一,先备份一下 graylog 的配置. mongodump -h dbhost -d dbname -o dbdirectory
防止分布式部署的使用搞坏了.之后的恢复可以使用
mongorestore -h dbhost -d dbname --directoryperdb dbdirectory
来恢复.相关说明可以参考这里
之后就可以正式开始了
修改集群名字
在/etc/mongod.conf 中,修改这个值.设置集群使用的集群名称是 graylog,几个机器都配置一下.都先不要启动
replication: replSetName: graylog
然后添加集群配置
启动其中一台,然后通过mongo 命令连接上数据库,依次执行下面的命令.注意,这里有个坑.添加本机的时候,一定要写对外的域名或者 ip.否则会导致无法选主.
rs.initiate() rs.add("&lt;hostname>:27017") rs.add("&lt;hostname>:27017") rs.add("&lt;hostname>:27017") rs.conf() 开始启动
这里启动就不用说了. service mongod start 启动就好了.
配置 graylog 集群连接地址
在/etc/graylog/server/server.conf 中配置.mongodb_uri = mongodb://host1,host2,host3/graylog
后面这个 graylog 就是给 graylog 使用的库名,你可以先创建.
之后mongodb 就开始自行同步了.
[参考]
高可用的MongoDB集群
​……<p class=readmore><a href=http://leaver.me/2016/11/06/graylog%E4%B8%AD%E7%9A%84mongodb%E9%85%8D%E7%BD%AE/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2015/08/08/angularjs-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/>AngularJS 学习资源</a></h1></header><date class="post-meta meta-date">2015年8月8日</date><div class=post-content>一直对AngularJS很好奇,之前看过国内某在线网站的一套AngularJS教程,可惜没看懂.也没理解为了解决什么问题,只是知道是个前端JS框架.这周看到个Udemy - Learn and Understand AngularJS 这个教程.去看了一下,是收费的.强烈推荐看.无字幕,但是不难,已经看完了.讲的非常非常好.网上有别人分享的.我给个磁力链接吧.
01 Getting Started
02 Model, View, Whatever___
03 Services and Dependency Injection
04 Data Binding and Directives
05 Single Page Applications
06 Custom Services
07 Custom Directives
08 Lets Build an App in record time
09 BONUS Lectures
10 Getting Ready for AngularJS 2.0 in 2016
11 Conclusion
非常的介绍.看完之后,你会理解AngularJS解决了什么问题,他的数据绑定怎么使用,模块怎么弄,怎么写服务,怎么定义指令等等.强烈推荐.
最好有一点js和css的基础会比较好理解.如果懂后端开发的就更好了.依赖注入这些有点基础会比较好理解.……<p class=readmore><a href=http://leaver.me/2015/08/08/angularjs-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/07/17/%E4%BD%BF%E7%94%A8css3%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96%E6%96%87%E5%AD%97/>使用CSS3的自定义字体美化文字</a></h1></header><date class="post-meta meta-date">2013年7月17日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>之前看到一些设计师的主题的字体很美，下载下来发现使用了css3的自定义字体，可以用来显示服务器上的字体，非常方便，学习了一下
1.首先得到字体
这个方法很多，本机的字体，一些国外的免费网站，比如这个：http://www.dafont.com，下载后的字体一般为ttf格式，ttf字体被很多浏览器支持，但是，IE不支持，为了兼容性，需要为IE单独设置字体文件，格式必须为eot，所以我们需要转换字体，使用在线工具，比如http://www.kirsle.net/wizards/ttf2eot.cgi，当然类似的网站有很多，根据个人爱好，随意。
 2.添加内容
这里，我写一个简单的html文件，内容为
在没有设置customFont这个类的css之前，字体就是默认的字体了。
 3.设置css样式
显示效果就是这样的了&mldr;只是用来演示的一个字体。
 因为浏览器是要自动下载这个字体文件的，所以对于英文字体没啥问题，英文字体一般这个字体文件在100k左右，和一张图片比起来，基本算不是问题，但是对于中文字体，包一般在10M-20M左右，这样是不现实的，我的想法是，可以自己制作字体包，这样只需要满足常用的一些汉字就行了，大大减少包的大小，然后去找了一下，发现了http://www.high-logic.com/font-editor/fontcreator.html这个软件，是可以直接编辑字体包的，也可以创建字体包，有空了用来试试.……<p class=readmore><a href=http://leaver.me/2013/07/17/%E4%BD%BF%E7%94%A8css3%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96%E6%96%87%E5%AD%97/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/05/22/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88c-/>引用和指针(C++)</a></h1></header><date class="post-meta meta-date">2013年5月22日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>今天在整理收藏夹的时候，又看到了这两篇非常不错的文章，关于指针和引用的，我就不翻译了，文章很简单，不过把其中我觉得很有意思的两部分结合我的理解希望说的更清楚,假定你读这篇文章之前已经知道指针，但是不是很清楚其中的部分。
首先是关于指针的一个直观的一个认识.
上面这段代码，声明了一个指针，和两个整数，指针指向第一个整数，然后输出结果（每个人的输出结果不一样）是：
这张图是这几个变量的内存分布图，上面一排是内存地址编号，正对我们的是该处的值
指针pPointer这个变量从最左边0xbff43314这个内存位置开始，占用了四个字节，这个一个指针占四个字节，大家都知道的，这个变量的值是一个地址，也就是他的指向地址。
pPointer 所指向的地址呢，是一个short int 类型的值所在的位置，在这里就是我们的twoint，twoint在内存中呢，是从0xbff4331a开始的，也就是说，我们的pPointer指向了twoint所在的地址，
注意，看一下左边四个方块前面的二进制数，转换成16进制就是0xbff4331a了
因此，取指针所指向的值就是35698了。指针本身的值则是0xbff4331a，指针所在的位置是0xbff43314。
参考文章：C++ : Understanding pointers
 另一个呢是关于引用的实现原理
大家都知道，引用就是别名，比如下面这段代码
输出结果肯定一目了然，其中的原理想过没
其实，引用和指针的工作原理类似，引用变量存储了其引用变量的地址，看图
 refNumber这个引用变量在内存中的值就是number这个被引用变量的地址.但和指针不同的是，引用是对一个地址的命名常量，因此，必须在声明引用的时候初始化。并且取值的时候，也不需要像指针一样加*，而是当作一个普通变量，直接用就行了。
参考文章：Pointers, References and Dynamic Memory Allocation
  ……<p class=readmore><a href=http://leaver.me/2013/05/22/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88c-/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/05/15/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3c-/>倒水问题求解(C++)</a></h1></header><date class="post-meta meta-date">2013年5月15日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>明天要去参加微软面试，不求顺利，但求体验。
这个题目答题的意思是:
给你一个容量为A升的桶和一个容量为B升的桶，水不限使用，要求精确得到Q升水.请说明步骤
当数字比较小的时候,我们可以通过大脑穷举来得到结果,但这里有两个问题,当数字很大的时候怎么解?题目给定的数据是否有解?
首先判断是否有解?
题目可以理解为,x为用A的次数,y为用B的次数,Q为目标值
Q = A * x + B * y Q =目标值.
Q必须是 Gcd(A,B)(也就是A,B的最大公约数)的倍数,否则无解,如果 Gcd(A,B) == 1, 任何Q都是可解的
最简单的方法就是把A的水不断的向B中倒(B向A中倒也行),知道得到最终结果,如果桶满了,就清空该桶.举个例子
A = 3, B = 4 并且 Q = 2 重复得从 A->B
A B
0 0 4 0 1 3 1 0 0 1 4 1 2 3 &lt;-A桶中得到2了
试试从 B->A
A B
0 0 0 3 3 0 3 3 4 2 &lt;- B中也得到了2 但是注意,从 B->A 比从 A->B快哦
然后我贴出代码
运行结果如下：
关于如何求最少的步数来求解这个问题，希望有朋友能够留言指教。……<p class=readmore><a href=http://leaver.me/2013/05/15/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3c-/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/04/16/%E6%A8%A1%E6%9D%BF%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8Fc-%E5%AE%9E%E7%8E%B0/>模板优先级队列及堆排序(C++实现)</a></h1></header><date class="post-meta meta-date">2013年4月16日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>模板优先级队列，数组实现，再熟悉一下常用算法，同时简单的堆排序应用
写了一个是队列自增长，另一个为了演示我还添加了一个叫做FillPq的方法，这个方法可以使用一个数组直接填充到优先级队列里，此时，优先级队列并不优先，然后进行下滤调整，之后建堆完成，输出即可
然后是堆排序
 ……<p class=readmore><a href=http://leaver.me/2013/04/16/%E6%A8%A1%E6%9D%BF%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8Fc-%E5%AE%9E%E7%8E%B0/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/04/11/%E6%A8%A1%E6%9D%BF%E6%A0%88%E4%BB%A5%E5%8F%8A%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BCc-%E5%AE%9E%E7%8E%B0/>模板栈以及中缀表达式求值(C++实现)</a></h1></header><date class="post-meta meta-date">2013年4月11日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>栈直接用链表实现，这个比较简单，不多说，不过C++写程序，IDE的错误检测不是很给力。
至于给定一个中缀表达式，如何不转换成后缀表达式，直接求值，方法就是使用两个栈，一个操作符栈，一个操作数栈，然后从左到右扫描表达式，我这里中缀表达式计算实现的很简单，不完整，大家可以扩展。栈的实现是我想写的，思路如下：
1.如何是操作数，压入操作数栈
2.如果是操作符，压入操作符栈
3.如果是左括号，直接忽略
4.如果是有括号，弹出操作符栈栈顶元素，然后弹出操作数栈两个元素，进行操作以后结果压入操作数栈
 看个图就好了
 最后给出栈顶实现代码
然后是main函数代码
另外，今天是博客建站一周年.加油！……<p class=readmore><a href=http://leaver.me/2013/04/11/%E6%A8%A1%E6%9D%BF%E6%A0%88%E4%BB%A5%E5%8F%8A%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BCc-%E5%AE%9E%E7%8E%B0/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/04/11/%E5%B9%B6%E6%9F%A5%E9%9B%86c-%E5%AE%9E%E7%8E%B0/>并查集(C++实现)</a></h1></header><date class="post-meta meta-date">2013年4月11日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>并查集这个很有意思，并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。昨天看书看到了，然后用C++简单实现了下。在Dijkstra算法中，用来判断两个顶点是否在同一个集合里。
里面定义了两个类，都是并查集，一个是QuickFind，查找很快，一个是QuickUnion，合并较快。写了一些注释，有一些优化的提示.看代码吧，有什么问题指出来吧。
QuickFind的实现
QuickUnion的实现
参考文档(英文)：UnionFind.pdf
工程代码下载：并查集Demo……<p class=readmore><a href=http://leaver.me/2013/04/11/%E5%B9%B6%E6%9F%A5%E9%9B%86c-%E5%AE%9E%E7%8E%B0/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/02/21/c#%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F/>C#反射实现简单的插件系统</a></h1></header><date class="post-meta meta-date">2013年2月21日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>如果用过一些优秀的开源或是非开源的应用软件，就会发现这些软件的一个很大的优势就是其开放性，任何有能力的人都可以为其开发不同的插件来增强其的功能。比如著名的foobar2000，Vim和TotalCommander等等。
C#的反射可以用来实现一个简单的插件系统。思路很简单，我们创建一个解决方案，包含三个工程，一个为我们的软件MyApplication，一个为插件接口IPlugin，一个为具体的插件MyPlugin。插件系统的基本思路是我们用一个接口类库,来定义我们软件可以使用的插件必须实现的方法签名。然后我们的软件MyApplication通过引用该IPlugin dll来动态调用，而具体的实现插件MyPlugin则引用该接口来实现具体的方法。这样我们的应用程序就能在不知道具体插件的情况下调用插件了。。
结构图如下：
关键代码也就是通过对程序集载入。搜索到对应接口的实现类。然后调用即可。……<p class=readmore><a href=http://leaver.me/2013/02/21/c#%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F/>阅读全文</a></p></div></article><article class=post><header><h1 class=post-title><a href=http://leaver.me/2013/01/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/>操作系统中的文件系统</a></h1></header><date class="post-meta meta-date">2013年1月31日</date><div class="post-meta meta-category">|
<a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0>学习笔记</a></div><div class=post-content>文件系统 进程，地址空间，文件这些抽象概念均是操作系统中的重要概念，如果理解了这三个概念，就迈上了成为一个操作系统专家的道路。 文件系统存放在磁盘上，多数磁盘划分为一个/多个分区，每个分区有一个独立的文件系统，磁盘的0号扇区称为主引导记录，也就是MBR，用来引导计算机，MBR的结尾就是分区表了。该表给出了每个分区的起始和结束地址。表中的一个分区被标记为活动分区。在计算机被引导时，BIOS读入并执行MBR，MBR做的第一件事就是确定活动分区，读入他的第一个块，称为引导块，并执行之，引导块中的程度将装载该分区中的操作系统，为统一起见，每个分区都从一个启动块开始，即使它不含有一个可以启动的操作系统。 文件的实现： 1.连续分配，每个文件作为一连串连续数据存储在磁盘上。实现简单，读操作性能好，一次就可以了。但不足是删除之后不能移动，因为成本太高，使得空块增多。碎片化严重。更诡异的是对于文件编辑软件，实现无法准确预测大小，如果预测错了。。就跪了。 //研究那些具有清晰和简洁概念的老式系统和思想是很重要的，因为他们可能以一种令人吃惊的方式在未来系统中获得应用。
2.链表分配 为每个文件构造磁盘块链表，一个文件分为N个文件块，N个文件块构成一个链表，存储在物理上的多个地方。顺序读取很方便，但随机读取则相当缓慢，由于指针的存在，每个磁盘块存储数据的字节不再是2的整数次幂，导致系统运行效率降低，因为很多程序都是以2的整数次幂来读写磁盘的。
3.在内存中采用表的链表分配 去除每个文件块在磁盘上的指针字，放入内存的一个表上，就可以解决上一个分配的不足。直观的例子如图。 文件A使用了磁盘块4，7，2，10，12
内存中这样的表格称为文件分配表，也就是FAT了。主要缺点是对于大磁盘的小块，这种表需要的内存占用太大。。不太适用。
4.i节点 记录各个文件包含哪些磁盘块的方法是给每个文件赋予一个称为i节点的数据结构,其中类除了文件属性和文件块的磁盘地址.相对于在内存中采用表的方式,这种机制的优势在于只有对应文件打开时,其i节点才进入内存.
文件系统的一致性检查分为两种:块的一致性检查和文件的一致性检查.构造两张表,一张跟踪块在文件中的出现次数,另一张跟踪该块在空闲表中的出现次数,如果一致,则某一块必然在两个表中1/2中为1,如果某一块没有出现在任何一张表中,则称为块丢失,浪费了磁盘空间.解决方法是让文件系统检验程序把他们加入到空闲表中 如果在空闲表中出现了两次.则重新建议建议空闲表即可. 如果在文件表中出现了两次.则比较麻烦.
文件系统性能 1.高速缓存,最常用,指的是一系列的块,逻辑上属于磁盘.但实际上被保存在内存上.基本算法是检查全部的读请求,查看在高速缓存中是否有所需要的块,如果存在,就读,否则读入高速缓存在复制到其他地方. 2.块提前读,在需要用到块之前,试图提前将其写入高速缓存,从而提高命中率.比如某个文件有n个块,则请求k块的时候,则同时预读k+1块.只适用于顺序读取的文件,对随机读取文件,则没有效果/反效果. 3.减少磁盘臂运动 把所有可能顺序读取的块放在一起,当然最好是放在同一个柱面上,从而减少磁盘臂的移动次数.……<p class=readmore><a href=http://leaver.me/2013/01/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/>阅读全文</a></p></div></article><ol class=page-navigator><li class=current><a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/>1</a></li><li><a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/page/2/>2</a></li><li><a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/page/3/>3</a></li><li><a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/page/4/>4</a></li><li><a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/page/5/>5</a></li><li><a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/page/6/>6</a></li><li class=next><a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/page/2/>下一页</a></li></ol></div></div><div id=secondary><section class=widget><form id=search action=http://leaver.me/search/ method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=http://leaver.me/>
<button type=submit class="submit icon-search"></button></form></section><section class=widget><h3 class=widget-title>最近文章</h3><ul class=widget-list><li><a href=http://leaver.me/2020/01/08/2019-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/ title="2019 年终总结">2019 年终总结</a></li><li><a href=http://leaver.me/2020/01/06/%E7%90%86%E8%A7%A3-cap-%E7%90%86%E8%AE%BA/ title="理解 CAP 理论">理解 CAP 理论</a></li><li><a href=http://leaver.me/2019/12/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3raft%E5%8D%8F%E8%AE%AE/ title=深入理解Raft协议>深入理解Raft协议</a></li><li><a href=http://leaver.me/2019/10/27/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E7%AC%94%E8%AE%B0/ title=《非暴力沟通》笔记>《非暴力沟通》笔记</a></li><li><a href=http://leaver.me/2019/10/06/wedding-of-friends/ title="Wedding of Friends">Wedding of Friends</a></li><li><a href=http://leaver.me/2019/09/29/principle-note/ title="Principle Note">Principle Note</a></li><li><a href=http://leaver.me/2019/09/14/%E6%A2%A6%E8%A7%81%E9%B2%B8%E9%B1%BC%E7%9A%84%E9%82%A3%E4%B8%80%E5%A4%9C/ title=梦见鲸鱼的那一夜>梦见鲸鱼的那一夜</a></li><li><a href=http://leaver.me/2019/08/20/understand-hong-kong-2/ title="Understand Hong Kong 2">Understand Hong Kong 2</a></li><li><a href=http://leaver.me/2019/08/18/understand-hong-kong-part-1/ title="Understand Hong Kong Part 1">Understand Hong Kong Part 1</a></li><li><a href=http://leaver.me/2019/07/09/%E9%94%99%E8%BF%87%E7%9A%84%E9%83%BD%E6%98%AF%E5%91%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%89%8D%E6%98%AF%E4%BA%BA%E7%94%9F/ title=错过的都是命，得到的才是人生>错过的都是命，得到的才是人生</a></li></ul></section><section class=widget><h3 class=widget-title>分类</h3><ul class=widget-list><li><a href=http://leaver.me/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记 (187)</a></li><li><a href=http://leaver.me/categories/%E6%88%91%E7%9A%84%E7%BF%BB%E8%AF%91/>我的翻译 (57)</a></li><li><a href=http://leaver.me/categories/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/>文章收藏 (53)</a></li><li><a href=http://leaver.me/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/>生活记录 (3)</a></li><li><a href=http://leaver.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记 (4)</a></li></ul></section><section class=widget><h3 class=widget-title>标签</h3><div class=tagcloud><a href=http://leaver.me/tags/android/>android</a>
<a href=http://leaver.me/tags/c/>C＃</a>
<a href=http://leaver.me/tags/c++/>C++</a>
<a href=http://leaver.me/tags/java/>java</a>
<a href=http://leaver.me/tags/javascript/>javascript</a>
<a href=http://leaver.me/tags/linux/>linux</a>
<a href=http://leaver.me/tags/mac/>mac</a>
<a href=http://leaver.me/tags/matlab/>matlab</a>
<a href=http://leaver.me/tags/maven/>maven</a>
<a href=http://leaver.me/tags/mysql/>mysql</a>
<a href=http://leaver.me/tags/nextgen-gallery/>NextGEN Gallery</a>
<a href=http://leaver.me/tags/php/>php</a>
<a href=http://leaver.me/tags/python/>python</a>
<a href=http://leaver.me/tags/shell/>shell</a>
<a href=http://leaver.me/tags/spring/>spring</a>
<a href=http://leaver.me/tags/sql/>sql</a>
<a href=http://leaver.me/tags/stackoverflow/>stackoverflow</a>
<a href=http://leaver.me/tags/wcf/>WCF</a>
<a href=http://leaver.me/tags/web/>web</a>
<a href=http://leaver.me/tags/windows/>windows</a>
<a href=http://leaver.me/tags/wordpress/>wordpress</a>
<a href=http://leaver.me/tags/wpf/>WPF</a>
<a href=http://leaver.me/tags/%E4%B8%8A%E6%B5%B7/>上海</a>
<a href=http://leaver.me/tags/%E4%B8%8B%E8%BD%BD/>下载</a>
<a href=http://leaver.me/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/>中间件</a>
<a href=http://leaver.me/tags/%E4%BA%92%E8%81%94%E7%BD%91/>互联网</a>
<a href=http://leaver.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a>
<a href=http://leaver.me/tags/%E5%88%B6%E5%BA%A6/>制度</a>
<a href=http://leaver.me/tags/%E5%89%8D%E7%AB%AF/>前端</a>
<a href=http://leaver.me/tags/%E5%8E%9F%E5%88%9B/>原创</a>
<a href=http://leaver.me/tags/%E5%A4%A7%E5%AD%A6/>大学</a>
<a href=http://leaver.me/tags/%E5%AD%A6%E4%B9%A0/>学习</a>
<a href=http://leaver.me/tags/%E5%AE%89%E5%85%A8/>安全</a>
<a href=http://leaver.me/tags/%E5%AE%B6%E5%BA%AD/>家庭</a>
<a href=http://leaver.me/tags/%E5%B7%A5%E4%BD%9C/>工作</a>
<a href=http://leaver.me/tags/%E5%B7%A5%E5%85%B7/>工具</a>
<a href=http://leaver.me/tags/%E5%B9%B6%E5%8F%91/>并发</a>
<a href=http://leaver.me/tags/%E5%BA%8F%E5%88%97%E5%8C%96/>序列化</a>
<a href=http://leaver.me/tags/%E5%BC%80%E5%8F%91/>开发</a>
<a href=http://leaver.me/tags/%E5%BF%83%E7%90%86/>心理</a>
<a href=http://leaver.me/tags/%E6%80%BB%E7%BB%93/>总结</a>
<a href=http://leaver.me/tags/%E6%8A%80%E6%9C%AF/>技术</a>
<a href=http://leaver.me/tags/%E6%8F%92%E4%BB%B6/>插件</a>
<a href=http://leaver.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<a href=http://leaver.me/tags/%E6%94%B6%E8%97%8F/>收藏</a>
<a href=http://leaver.me/tags/%E6%95%B0%E5%AD%A6/>数学</a>
<a href=http://leaver.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
<a href=http://leaver.me/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/>数据挖掘</a>
<a href=http://leaver.me/tags/%E6%96%87%E7%AB%A0/>文章</a>
<a href=http://leaver.me/tags/%E6%99%BA%E8%83%BD/>智能</a>
<a href=http://leaver.me/tags/%E6%9D%82%E6%96%87/>杂文</a>
<a href=http://leaver.me/tags/%E6%AD%A6%E6%B1%89/>武汉</a>
<a href=http://leaver.me/tags/%E6%B1%87%E7%BC%96/>汇编</a>
<a href=http://leaver.me/tags/%E7%88%B1%E6%83%85/>爱情</a>
<a href=http://leaver.me/tags/%E7%90%86%E8%AE%BA/>理论</a>
<a href=http://leaver.me/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/>生产力</a>
<a href=http://leaver.me/tags/%E7%94%9F%E6%B4%BB/>生活</a>
<a href=http://leaver.me/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/>电子书</a>
<a href=http://leaver.me/tags/%E7%94%B5%E5%BD%B1/>电影</a>
<a href=http://leaver.me/tags/%E7%A4%BE%E4%BC%9A/>社会</a>
<a href=http://leaver.me/tags/%E7%A7%91%E6%8A%80/>科技</a>
<a href=http://leaver.me/tags/%E7%AC%94%E8%AE%B0/>笔记</a>
<a href=http://leaver.me/tags/%E7%AE%97%E6%B3%95/>算法</a>
<a href=http://leaver.me/tags/%E7%BC%96%E7%A8%8B/>编程</a>
<a href=http://leaver.me/tags/%E7%BC%96%E8%AF%91/>编译</a>
<a href=http://leaver.me/tags/%E7%BF%BB%E8%AF%91/>翻译</a>
<a href=http://leaver.me/tags/%E8%81%8C%E4%B8%9A/>职业</a>
<a href=http://leaver.me/tags/%E8%AE%B0%E5%BD%95/>记录</a>
<a href=http://leaver.me/tags/%E8%AE%BE%E8%AE%A1/>设计</a>
<a href=http://leaver.me/tags/%E8%AF%BB%E4%B9%A6/>读书</a>
<a href=http://leaver.me/tags/%E8%BD%AF%E4%BB%B6/>软件</a>
<a href=http://leaver.me/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/>软件测试</a>
<a href=http://leaver.me/tags/%E8%BF%90%E7%BB%B4/>运维</a>
<a href=http://leaver.me/tags/%E9%87%91%E8%9E%8D/>金融</a></div></section><section class=widget><h3 class=widget-title>友情链接</h3><ul class=widget-list><li><a target=_blank href=https://www.cppfans.org/ title=C++爱好者博客>C++爱好者博客</a></li><li><a target=_blank href=http://www.kailing.pub title=KL，每天进步一点点>KL，每天进步一点点</a></li></ul></section><section class=widget><h3 class=widget-title>其它</h3><ul class=widget-list><li><a href=http://leaver.me/index.xml>文章 RSS</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href=http://leaver.me/>bystander's blog By bystander</a>.
Powered by <a rel="nofollow noreferer noopener" href=https://gohugo.io target=_blank>Hugo</a>.
<a href=https://www.flysnow.org/ target=_blank>Theme</a> based on <a href=https://github.com/flysnow-org/maupassant-hugo target=_blank>maupassant</a>.</div></footer><a id=rocket href=#top></a><script type=text/javascript src="/js/totop.js?v=0.0.0" async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-30961201-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>