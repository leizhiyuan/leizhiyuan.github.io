<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on bystander&#39;s blog</title>
    <link>http://leaver.me/tags/linux/</link>
    <description>Recent content in linux on bystander&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 29 Mar 2014 10:31:31 +0000</lastBuildDate>
    
	<atom:link href="http://leaver.me/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>linux编写定时任务</title>
      <link>http://leaver.me/2014/03/29/linux%E7%BC%96%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Sat, 29 Mar 2014 10:31:31 +0000</pubDate>
      
      <guid>http://leaver.me/2014/03/29/linux%E7%BC%96%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>linux中定时任务用来执行一些周期性的自动化的任务，比如有些人可能用来定期备份，也可能是定期检查一下特殊文件的签名，如果不一致，就报警，检测入侵。
cron是linux下的定时执行工具
这个工具的几个命令是这样的
注意，这几个服务都是要以root权限才能运行的，很多时候，只要我们可能只是一个低权限的用户，那么我们要执行一些定时任务的时候，可以这样做
直接通过这个命令来编辑，无需root用户
首先添加定时任务
打开之后按如下的格式编写
从左到右一次表示
分钟 一小时的第几分 0-59 小时 一天的第几小时 0-23 日期 一个月的的第几天 1-31 月份 一年的第几个月 1-12 周几 一周的第几天 0-6
/1表示每一天 /2表示每两天，直接*的话就表示每天/每小时这样
写完之后，wq保存退出
然后
可以看到自己的定时任务了，然后就不要做什么操作了，操作系统定时会读取配置的，编辑完成之后，我们的定时任务过一会就会生效了。
有时候，可能还要把结果信息和一些错误信息也写入
这里就是说明天的5点50执行一次ls命令，并把结果追加到文件
如果我想每天5点30和17点30都执行一次呢，使用逗号隔开就行了
如果是某个时间段呢
这样5-17点钟的每个30分到会执行
如果是一些特殊的时间点，那么有更简单的方法，比如每月0点或者每天0点执行一次
使用如上的关键字</description>
    </item>
    
    <item>
      <title>linux的CPU负载均值</title>
      <link>http://leaver.me/2014/03/08/linux%E7%9A%84cpu%E8%B4%9F%E8%BD%BD%E5%9D%87%E5%80%BC/</link>
      <pubDate>Sat, 08 Mar 2014 17:19:30 +0000</pubDate>
      
      <guid>http://leaver.me/2014/03/08/linux%E7%9A%84cpu%E8%B4%9F%E8%BD%BD%E5%9D%87%E5%80%BC/</guid>
      <description>当运行在Linux上的程序有问题之后，我们通常要看一下当前CPU和内存的使用情况来分析一下问题
对于CPU的使用率，通常用Load Average，也就是负载均值来度量
负载均值是啥？
负载是啥，负载就是对CPU使用率的一个计量，均值就是某一段时间内的一个平均值。
怎么看啊？
直接输入w命令
第一位1.20：表示最近1分钟平均负载 第二位1.28：表示最近5分钟平均负载 第三位1.29：表示最近15分钟平均负载
或者uptime命令
我们一般认为0.00表示无负载，可以理解为CPU空闲，1.00表示CPU满负载，但是注意，1.00是对于单cpu来说的，也就是说，如果是双核，那么这个满负载显示的值应该是2.00，以此类推。
怎么看我是几核啊
通过统计cpuinfo的model name信息来算的
这三个值哪个重要？
一分钟内突然负载很大没关系，当然如果你要排查也没人拦着，如果15分钟的负载均值超过cpu的数目，就要关注了。
那什么就是理想负载呢？
以单个cpu为例，1.00表示cpu满负载运行，没有一点点浪费，实际上，有些管理员认为0.7也许是理想的状态。如果你的经常超过0.7，那么最好查一查。</description>
    </item>
    
    <item>
      <title>[笔记]写代码遇到的一些问题汇总下</title>
      <link>http://leaver.me/2014/02/08/%E7%AC%94%E8%AE%B0%E5%86%99%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8B/</link>
      <pubDate>Sat, 08 Feb 2014 11:06:51 +0000</pubDate>
      
      <guid>http://leaver.me/2014/02/08/%E7%AC%94%E8%AE%B0%E5%86%99%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8B/</guid>
      <description>本篇是用来填上一篇 挖下的坑的。
1.java调用webservice
有一些已有的webservice服务，由xfire生成发布，有些有参数，有些无参数，无参数的直接我直接使用org.codehaus.xfire这个包里的Client来动态生成客户端。然后调用就可以了。非常简单
但对于有参的，且是服务器自定义的类作为参数的时候，实在是搞不定。。不管是把自定义的类放到本地，包名一致，在invoke的时候生成这个对象还是其他什么方法。都无法完成。
最终换了直接发送soap报文来完成。dirty hack啊。如果你有一些好的方法希望不吝赐教。
解决方案来源自stackoverflow，因为stackoverflow现在国内好像有时候打不开。因此把代码贴过来。有疑问的话留言讨论。
2.Access restriction on class due to restriction on required library rt.jar? 报错
总么都感觉是环境问题，系统bug。解决如下：
 进入project properties的 Build Path 设置里. 移除 JRE System Library 再添加回来，方法是: 选择 &amp;ldquo;Add Library&amp;rdquo; ，然后选择 JRE System Library.   3.SSHManager类报错：com.jcraft.jsch.JSchException: UnknownHostKey
我使用的一个SSHManager类如下：
报这个错是因为
连接这段代码里少了config.put(&amp;ldquo;StrictHostKeyChecking&amp;rdquo;, &amp;ldquo;no&amp;rdquo;);这段设置，这个是去掉了严格的安全检查，一般只用于测试目的。
4.navicat连接oracle数据库
之前使用PL/SQL操作Oracle数据库，使用Heidisql操作mysql数据库。。切换麻烦。而且PL/SQL搜索的时候中文有问题。于是打算使用navicat统一管理
方法是：
1.首先下载Instant Client 的32位版本和Navicat Premium
2.然后解压Instant Client，配置navicat

选择oci文件即可
然后新建oracle配置，选择basic模式，其他的根据你的数据库信息自己填写即可。
 5.HttpClient的logger日志实在太多了
大人，实在太多了。看不过来啊。附赠一篇log4j配置文件详解
在log4j.properties文件中添加如下配置信息
log4j.logger.httpclient.wire.header=INFO
log4j.logger.httpclient.wire.content=INFO
log4j.logger.org.apache.commons.httpclient = INFO
最后附赠一些实用的工具
http://www.freeformatter.com/ 程序员必备。各类转换，包括转义工具，格式校验工具。效果很好。
流体力学理论与F1赛车的空气动力学1，2，3 什么雷诺数，伯努利方程，文丘里效应，当年木有好好学啊。这么高大上的东西果然还是有压力。</description>
    </item>
    
    <item>
      <title>Unix sed实用教程系列目录</title>
      <link>http://leaver.me/2013/08/11/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Sun, 11 Aug 2013 17:03:51 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/11/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95/</guid>
      <description>本系列文章已经译完了，译自awk-sed@theunixschool,收获颇丰，作者没有将明白的我做了补充，并且尝试讲的更清楚，整理成系列索引，方便学习，开篇非译文,是我为了方便后面的理解写的一篇,感谢原作者的分享.有任何问题欢迎留言讨论.
 Unix sed实用教程开篇 [译]Unix sed实用教程第一篇–向文件中增加一行 [译]Unix sed实用教程第二篇–替换文件内容 [译]Unix sed实用教程第三篇–读写文件 [译]Unix sed实用教程第四篇–选择性打印 [译]Unix sed实用教程第五篇–替换文件内容续 [译]Unix sed实用教程第六篇–删除文件内容 [译]Unix sed实用教程第七篇–输出文件内容(10 Demo) [译]Unix sed实用教程第八篇–CSV文件操作  </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第八篇–CSV文件操作</title>
      <link>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87csv%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 11 Aug 2013 16:55:33 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87csv%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>本文作为sed使用教程的最后一篇，将比较全面的讲解如何操作csv文件，csv文件通过逗号分隔
示例文件如下：
1.删除第一列s开启替换模式，当^符号在中括号里的时候，就是非的意思，也就是说[^,]匹配了所有不是逗号的一个字符，然后后面的星号表示0个或多个，然后是一个逗号，也就是匹配&amp;quot;xxxx,&amp;ldquo;替换为空
2.删除除过最后一列的其他所有sed先匹配任意多个字符，然后匹配最后一个“,”这就直接把前面的都匹配完了。替换为空即可。
3.输出第一列好理解把，先匹配第一列之后的逗号，然后是多个字符，然后替换为空
4.删除第二列先匹配第一列之后的逗号，然后匹配一个或多个非逗号字符，这样就匹配了第二列的内容，然后再匹配一个逗号，我简化一下，比如该列是1，2，3，4，那么这一个匹配就是&amp;rdquo;,2,&amp;quot;，替换成一个逗号，就是1，3，4了
5.输出第二列我们可以分析前两个斜线之间的内容
两个右斜线转移了括号，所以括号不是简单的符号，而是正则里的组的意义，圆括号的作用是对字符进行分组，并保存匹配的文本。这里先匹配非逗号的多个字符，然后一个逗号，然后再匹配第二列，并且第二列的匹配用括号括起来，然后匹配其他列，然后里面用\1来引用这个括号的内容，如果前面有两个括号，就可以使用\1或\2这样，分别表示第一个括号或第二个括号的匹配
6.输出最后一列是一位数字的行.*匹配了前面的所有字符，然后,匹配了最后一个逗号，sed的贪婪原则。。然后[0-9]匹配一个数字$表示行尾.ok
7.给每一行自动添加行号这个和cat -n file的效果是一样的。awk也可以很简单的做，这里使用一个=命令会在每一行之前添加一个行号，也就是是，如果执行
文件会是：
然后我们通过管道再执行
N表示读入并合并下一行，然后将两行之间的换行符替换为空即可了
8.如果第一列是Ubuntu，就把最后一列替换成99中间的
匹配“Ubuntu,任意个字符,任意个字符”,也就是将行分成几组，将本行替换成第一组的内容第一组的内容，第二组的内容，但最后的一列被替换成99，就这样。
9.如果第一列是RedHat就删除第二列也好理解嘛。将要保留的用括号分组，然后用\1和\2分别引用第一组和第二组，然后中间的匹配就被删除了
10.在末尾插入一列正则首先匹配了整行字符，然后使用&amp;amp;来引用该匹配，然后添加了一个逗号和一个A
11.在头部添加一列
很简单不是么&amp;hellip;
比预计的要快，两天翻译完了.体会到了理解原理对学习sed的好处，希望对想学的人有帮助.
          </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第七篇–输出文件内容(10 Demo)</title>
      <link>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AF%87%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B910-demo/</link>
      <pubDate>Sun, 11 Aug 2013 16:27:31 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AF%87%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B910-demo/</guid>
      <description>之前已经学习过选择性打印输出了，本文将通过10个例子全面讲解文件输出的一些方法，主打p命令
首先看一下将使用的示例文件
1.打印文件首行之前讲过了，-n取消默认的全部打印，p表示print，1就是行号了
2.输出最后一行3.输出不匹配X的那些行也好理解，！表示非，就是说包含X匹配的不打印输出
4.输出包含u/x的那些行正则是强大的，这样就匹配了u/x
5.输出以x/X结尾的那些行这里$符号不再是匹配文件尾部，而是行尾，这是正则的规则
6.输出以A/L开头的行前面也说过，^匹配了行首，A表示A匹配，然而|则是或者的意思，为什么要加\转义，是为了避免被解析成pipe管道，后面的就不解释了
7.隔行打印n命令是输出当前行，然后读入下一行到pattern space的意思，这句命令是这么执行的，首先读入一行，然后通过n命令输出，然后通过n命令再读一行，然后把这行删除，就出现了隔行输出的效果
8.如何两行输出，隔两行再输出n;n; 命令呢输出了前两行，然后读入第三行到pattern space，N命令则对如下一行并与第三行合并，然后d命令删除pattern space中的内容，于是三四行被清空，然后读入56行，继续重复。就这样。作者这里给出的例子不直观，我举个例子，我的文件内容是
执行上面的命令后，会输出
明白了吧
9.输出某个范围行内以X结果的那些行这里首先制定了从/Unix/匹配开始到文件尾部的这些行，然后呢，在这些之间的行，如果以X结果，就输出。
10.输出不包括开始和结尾的那些行这个命令就会只输出/Solaris/和/HPUX/之间的行，不包括他们两个。
这里要说一下//这个，当匹配了Solaris的时候就进入了花括号，因为这个里面没有提供任何匹配，所以就考虑最后一次匹配模式，也就是相当于是考虑Solaris这一行，他不被打印，当到了HPUX这一匹配，//又代表了HPUX匹配，这一行也不打印。
Demo完了，你懂了么。</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第六篇–删除文件内容</title>
      <link>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AF%87%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Sat, 10 Aug 2013 13:15:38 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AF%87%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>其实，删除和替换是由一些相同的，不过，这里我们单独列出来，通过25个例子穿插讲解sed删除文件的一些方法，使用的示例文件如下：
1.删除第一行d就是删除，1就是指第1行，记得哦，这不会影响到源文件，一般，做删除的时候一般要加-i参数，前面说过了
2.删除指定行，这里删除第3行3.删除最后一行4.删除范围行，这里删除2-4行5.保留指定的行，这里保留2-4行！这个是对前面的2,4来操作，是非的意思，也就是不是2-4行的行，这样除去2-4行，其他的都删除了
6.删除第一行和最后一行分号隔开两个命令，你懂的，也可以删除第二行和第三行等等. &amp;lsquo;2d;3d&amp;rsquo;
7.删除以指定字符开头的行这里就把以L开头的Linux这一行删除了
8.删除以指定字符结尾的行这里就删除了，可以看到AIX没有删除，unix区分大小写你懂的
9.忽略大小写，都删除[xX]匹配x或X，所以就成功了嘛
10.删除文件中的空行^匹配开头，$匹配结果，中间啥都没有，这样就匹配了空行，但是注意哦，如果某一行全是空格，这个命令是不会删除这一行的。
11.删除空行或是仅仅包含空格的行如果你看我前面的文章，这个就不用我说了吧，0个或多个空格就是匹配了所有的空行了
12.删除完全是大写字母的行[A-Z]就匹配了26个大写字母的任意一个
13.删除包含Unix匹配的行14.删除不包含Unix的行15.删除包含Unix或Linux匹配的行这里要说的是|，这个本来是表示or，或的意思，但是在终端下，为了防止被认为是管道，所以要用\来转义
16.删除从第一行到满足匹配的行可以通过行号到模式，模式到行号等等组合来匹配
17.删除从Linux匹配到末尾的行18.如果最后一行匹配AIX就删除，否则就不删除$匹配了最后一行，也可以是行号，比如1，后面的大括号里就是条件和处理方式了，这样就在sed里实现了if条件了，再看一遍这个例子，熟悉一下这个规则
19.所处最后一行如果满足两个匹配20.如果1-4行满足Solaris匹配就删除21.删除包含Unix匹配的行，同时删除下一行N命令将下一行读入pattern space，什么。你忘了，看开篇去，这个命令就删除了两行
22.删除包含Unix的下一行作者这里没有说清楚，我讲一下，N读入了下一行，然后这时候pattern space里就相当于两行并作了一行，中间有一个换行符，所以pattern space里现在就是：
然后通过s命令匹配了\nLinux，并且替换为空，就ok了哦。
23.删除包含Linux模式的行，也包含上一行少年，不要怕，我们一步步来
首先，要知道，为了删除某一匹配的前一行，我们需要将文件的每一行放入到hold space里，一旦发现匹配，我们就开始删除连个缓冲区的内容，其中pattern space存储了当前行，hold space 存储了前一行
而x;p;这是啥呢，这两个命令是对每一行都会执行的，x表示exchange，即是交换hold space 和pattern space中的内容，p则是print，打印pattern space中的内容，因此，每次当前行被存入hold space，然后打印出了前一行的内容
当/Linux/匹配之后，我们使用s/.//来清空当前行，也就是pattern space为空了，当前行相当于被删了，然后使用x和hold space来交换，这样，就导致hold space为空了，然后使用d来删除pattern space的内容（此时pattern space里是交换过来的前一行的内容），因此，匹配Linnx的当前行和前一行都被删除了，
然后呢${x;p;}表示如果最后一行还在hold space里，就把他换出来，打印出来。
而后面的管道之后的命令呢，是吧第一部分sed命令之后产生的空行给删掉。
再理解一下
24.仅删除匹配Linux的前一行，不删除当前行和23类似，当匹配到Linux的时候，hold space 存储了前一行的内容，所以我们交换一下他们，然后前一行就进入了pattern space，然后一个d，这样就把前一行删掉了。别急，还没完，这样，当前行就被留在hold space了。就无法被输出了
1h;1!{x;p;} 1h是说，如果将第1行移动到hold space，也就是1h只对第一行操作，而后面的1!{x;p;}是说对于其他的行执行x;p;命令，
25.删除匹配模式的前后两行有了前面两个例子，自己试试理解一下，有问题留言讨论吧。</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第五篇–替换文件内容续</title>
      <link>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%AD/</link>
      <pubDate>Sat, 10 Aug 2013 09:05:55 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%AD/</guid>
      <description>前面已经学习过替换文件内容了，本文我们学习一些更频繁使用的搜索替换操作.
示例文件使用：
1.替换每行开始的两个字母，这里用XX来替换s代表substitute，前面说过了，^用来匹配行开头，.表示任意一个字符，两个..就是你懂的，
其实，不要^符号也是可以的，因为默认就是从开头开始匹配，如下也可以实现
2.删除每行开头的两个字符看到没有，后两个斜线之间没有内容，也就是用空字符来替换开头的两个字符，就实现了删除
3.要是想删除每行最后的两个字符呢再次强调，$在不同的情况下表示不同的意思，这里匹配行尾，有时候也匹配文件尾部
4.向每行末尾添加内容这里，先匹配行尾，然后把&amp;rdquo;.Rs&amp;quot;添加到行尾
5.在每行开头添加空格还记得前面说过的么，sed默认不影响原始文件，要是想更新原始文件，请加-i参数
6.移除开始的空格^匹配行首，然后是一个空格，然后是*，表示一个或多个空格嘛，然后替换为空字符
7.移除行首和行尾的空格不要怕，从分号处分开，就是两条命令啦，一个做行首的，一个做行尾的，前面说过的，可以使用-e参数来分开
8.如何在一个字符串前后添加一些其他字符呢，可以用来字符串转义前两个斜线匹配了所有字符，也就是本行，然后后面两个斜线是替换的内容，注意里面的&amp;amp;符号，之前也说过的，表示匹配到的字符，也就是本行了。所有就这样啦
9.移除行首和行尾的一个字符（多个你也会的啦）分开看看，你可以的
10.删除第一个数字之前的所有字符这条命令略复杂，请先回头看一下我们的示例文件，然后我们开始分析这个表达式，地一个^表示匹配行首，然后[^0-9]* 是一个典型的正则，匹配非数字的多个字符，简单说一下[0-9]表示匹配0,1,2,3,4,5,6,7,8,9任意一个字符，前面加个一个^，表示非，也就是不匹配这些数字，然后最后是一个*，表示匹配非数字的连续多个字符，有机会的话我会推荐一个正则系列，或者自己写一篇文章。这里就先这样理解吧。
那猜猜这个是干嘛的
是的，你猜对了，删除开头的所有非字母字符。
11.删除行尾的数字看看前面的你就知道了
12.通过分隔符得到文件最后一列可能你你预想的不一样，是不是，你可能认为会是第一列被删除，其他的列都在，不对的，sed是很贪心的，当我们指定&amp;rsquo;.*:&amp;lsquo;时，他会一直向后查找，尽量匹配更多，所以，就匹配到最后一个列之前了
13.转换整行字符为小写\L是sed的一个命令，Lowercase嘛。\L之后的内容被毁转换，而&amp;amp;表示前面匹配道德内容，所以就实现了转换
14.转换大写\U你懂的，Uppercase
  </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第四篇–选择性打印</title>
      <link>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87%E9%80%89%E6%8B%A9%E6%80%A7%E6%89%93%E5%8D%B0/</link>
      <pubDate>Sat, 10 Aug 2013 08:39:56 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87%E9%80%89%E6%8B%A9%E6%80%A7%E6%89%93%E5%8D%B0/</guid>
      <description>本文，我们将会学习如何选择性的打印（其实，这里的打印是print，也就是输出到标准输出的意思），用到的示例文件是：
1.打印所有内容一对单引号，没有任何参数即可
2.如何打印包含Gmail的那一行.(grep也可以实现这个功能)在斜线里面，我们指定正则匹配模式，p的意思呢，就是print，打印的意思，也就是打印包含Gmail这一行，但是我们看到Gmail打印了两次，为什么，因为sed的默认行为是在解析完一行之后就把他输出出来，也就是对于Gmail这一行，先执行p解析，解析完成后再默认打印一次，就打印了两次，而其他的，没有命令解析，直接读入完成后输出即可。
如果得到期望的结果呢？
-n参数会取消sed的默认打印行为，所以就ok了
3.删除包含Gmail的那一行。（grep -v也有同样的效果）d就是delete的意思，不多解释，
同样，要想删除某一指定的行
4.打印直到模式匹配，这里我们从头一直打印到Yahooq就是quit的意思，这条命令就是对于前面的行都没啥可解析的，执行默认的打印即可，一到碰到Yahoo这一行，打印完成，就停止，退出，因此，就是上面的了
打印某一指定范围行
到此，我们一直在学习基于一个条件取一行或多行，现在，我们来学习打印指定范围行
使用的示例文件如下：
5.打印前三行-n先取消默认打印，然后1,3指定行范围，p表示打印，你想一下我们前面的q命令，就知道下面这个命令效果是一样的
执行默认打印，到第三行的时候退出
6.通过模式指定范围，这里我打印从Yahoo到Live之间的行，包括本身不用多解释了
7.从指定模式到文件尾部，这里是从Redif到文件尾回忆一下$符号吧.少年
8.从开头到匹配模式相信你懂的&amp;hellip;
对于数字不需要斜线包围，对于匹配需要斜线.就这样..
  </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第三篇–读写文件</title>
      <link>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 09 Aug 2013 16:52:56 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>本文将展示如何将文件内容读入到sed输出，同时包含如何将一个文件的部分内容写入到另一文件
一.文件读取
假定有两个文件，file1和file2，内容分别如下：
sed有两个选项用来读写文件
看例子：
1.在file1的每一行读完之后读取file2的内容r file2读取file2的所有内容，因此r之前没有知道那个行号或匹配，因此有了上面的输出，记住，sed的工作机制，每次读file1的一行，然后执行命令
2.如何在读取了file1的第一行之后将file2读入r前面加个1就行了
3.当file1某行匹配了模式之后，读入file2sed逐行读入file1，然后判断该行是否匹配banana，如果匹配，就读入file2
4.当file1读取完成后读入file2，其实就是合并两个文件这里只是演示一下，其实cat file1 file2就可以完成合并
_**二.文件写入**_使用一个file1文件，内容如下：
1.将file1的2-4行写入到file22,4w就是写2-4行的意思，那-n呢？默认情况下sed会把读入的文件处理的结果输出到标准输出，也就是终端，而为了不使用默认输出，-n就派上用场了，执行该命令终端不会有任何输出
查看file2内容，发现已经写入成功了
2.从第三行开始全部写入file2就不多解释了
3.如果是用正则呢？该命令将逐行读入file1，然后判断该行是否匹配apple，如果匹配，则作为起始行，然后继续读入，判断是否匹配mango，如果是，则作为终止行，然后将中间的内容写入到file2
 </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第二篇–替换文件内容</title>
      <link>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Fri, 09 Aug 2013 16:24:12 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>上一节中-Unix sed实用教程第一篇–向文件中增加一行 学习了添加文件，本节讲解数据内容替换.
本节将使用sample1.txt文件作为示例，文件内容如下，都是些水果..：
1.向每一行的开头添加内容，这里我们添加“Fruit：”
解析：s代表substitution，也就是替换，s之后是要替换/匹配的内容，斜线/用来分隔s以及要替换的原始内容还有要替换的最终内容，而&#39;^&#39;符号是说一个正则，用来匹配每一行的开头，匹配成功后在开头加上&#39;Fruit:&#39;。
2.向每一行的行尾添加内容
注意，这里的$和上一节的$符号表示的意义不同，这里则是表示行尾.
3.如何替换指定的字符，这里将小写a替换成大写A
注意，仅仅将每一行的第一个a替换了，不是所有，本例表示替换单个字符，你可以替换一个单词都是可以的.
4.如何替换行内所有的字符，用A替换a
注意，只是加了一个g选项，g为global的简写，就是全局，全部的意思。
5.如何替换第二次出现的a?
不使用g，而是使用数字来表示行内第几次出现的a，结果如上
6.如何替换第二次之后的所有a呢？
很好理解对吧。
7.如果只想替换第三行的a呢？
回想一下第一节，在执行命令之前，会判断当前address是否满足条件，3就是地址
8.想替换一个范围行内的数据呢
逗号隔开，即可
9.如何替换整行呢？比如用apple is a Fruit替换apple
这里‘&amp;amp;’符号标识了模式匹配到的内容，而.*匹配了正行，.表示任意字符，*表示一个或多个，也就是匹配了整行,&amp;amp;因此就是整行内容，用来重命名一组文件的时候非常有用.
10.如何进行多个替换，比如用A替换a，用P替换p
也就是用分号分开即可。或者也可以通过-e参数来做
-e 选项就是当需要替换多个的时候来用的。
另外，要是替换的太多。也可以通过右斜线来分成多行
相信通过本文实例分析，平时的文件内容替换就很简单了</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第一篇--向文件中增加一行</title>
      <link>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</link>
      <pubDate>Fri, 09 Aug 2013 14:56:29 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</guid>
      <description>Unix sed实用教程第一讲，本系列第一篇，有任何问题欢迎留言讨论。
sed 是unix中最重要的编辑器之一，注意，有之一..支持多种编辑任务，本文将实现题目的功能实例
假定我们有一额文本文件，叫做empFile，包含了员工名字和员工id，如下：
1.如何通过sed给文件添加标题行-“Employee, EmpId”解释：数字1，是说只对第一行执行操作，i代表在insert（熟悉vim的同学应该知道，i会在当前字符的前面插入，a是在后面插入），因此，1i就表示在将Employee, EmpId插入到第一行之前，
然后，有了标题行的文件仅仅会输出到标准输出，源文件内容并不会改变，如果需要更新源文件，可以使用重定向输出到一个临时文件，然后移动到原始文件。如果Unix系统的sed是GUN版本的，sed会有一个-i选项，可以直接实现更新源文件，（如何查看版本，终端下输入sed &amp;ndash;version即可看到）下面先执行，再查看文件，发现已经多了标题行了
2.如何在标题行之后，也就是原始第一行之前添加一行横线&amp;ndash;“&amp;mdash;&amp;ndash;”同1，中，1表示第一行，a表示append（附加），也就是说当读入第一行的时候在其之后添加一行，如果你使用2i作为命令也是正确的，就是指当读入第二行的时候，在其之前插入一行。
3.如何在文件尾部添加一行为了在文件尾部插入一行，如果使用之前的方法就需要知道总共有多少行，而$符号则直接指明了最后一行，因此$a表示在读入最后一行的时候，在后面插入一行
4.如何在指定的记录之后插入一条新纪录假定我们的例子文件的内容现在是：
如果我想在Hilesh这个员工之后插入Bharti员工的信息，我这样做：
注意看，我们这里已经不再使用数字或者其他表示行号的标识了，我们使用了一个模式（了解过正则表达式的朋友会比较熟悉，可以理解为某种规则- /Hilesh/a 这个命令表示对于每一行读入的内容，如果发现 /Hilesh/这个匹配，在该行之后插入一行，也就是说如果文件里有两行都是Hilesh员工，那么执行完上面的命令，将会附加两行内容，这里可以想想sed的工作模式，对每一行执行命令条件检测，发现匹配，就执行。
5.如何在指定记录之前插入记录呢，比如，我想在Harshal这条记录之前插入Aparna记录呢？
 </description>
    </item>
    
    <item>
      <title>Unix sed实用教程开篇</title>
      <link>http://leaver.me/2013/08/09/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E5%BC%80%E7%AF%87/</link>
      <pubDate>Fri, 09 Aug 2013 09:43:52 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/09/unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E5%BC%80%E7%AF%87/</guid>
      <description>已经看了一段时间的Linux Shell编程了,也能完成一些基本的使用，为了加深理解，恰好看到了The Unix School的一个sed&amp;amp;awk教程，不是简单的命令参数堆积，而是一个相当实用的系列，因此，希望能在几天内完成翻译.翻译过程不会逐字翻译，会穿插一些注释，包括自己的一些理解和其他的一些引用，作为开篇，简单说一下sed的工作机制，对后面的理解会有很大帮助。
sed是什么： sed是一个非交互式的流编辑器（stream editor）。所谓非交互式，是指使用sed只能在命令行下输入编辑命令来编辑文本，然后在屏幕上查看输出；而所谓流编辑器，是指sed每次只从文件（或输入）读入一行，然后对该行进行指定的处理，并将结果输出到屏幕（除非取消了屏幕输出又没有显式地使用打印命令），接着读入下一行。整个文件像流水一样被逐行处理然后逐行输出。(via Walk in Mindfields ) sed工作机制： sed维护两个缓冲区，pattern space和hold space，命令开始执行之前都为空。
pattern space缓冲区用于临时保存每次读取的一行的内容，大部分的匹配和替换等等操作都是针对pattern space中的内容进行的，因此不会对输入文件有任何影响,而hold space则作为后备缓冲区使用,除非指定了一些特殊的命令(例如D删除命令)，否则pattern space中的内容会在处理完一行之后清空，但hold space中的内容在处理完每一行时不会被删除。
也就是说pattern space相当于我们的内存，hold space相当于硬盘.处理的时候在内存里，处理过的就放回硬盘.(这是我的理解，有一点点不恰当，但是因此一些概念会比较好理解.)
具体来说，可以大致分为以下几步：
 1.首先，从标准输入流读取一行，移除换行符，然后存入pattern space中
2.执行指定的命令,(每个命令都有一个可选的地址(可以是行号，也可能是一个正则表达式匹配)，这个地址作为一个执行命令前的测试，指定了需要对那些行进行操作。当前行只有匹配的情况下才会执行命令。）
3.当指定所有的命令都执行完了之后，pattern space内容就被处理过了，sed默认会将pattern space中的内容打印到标准输出中，移除的换行符也会打印出来。本行操作完成。
4.然后sed会读取下一行的内容，再次执行相同的操作。直到行尾。  基本上最基础的理论就差不多了.主要是这个工作机制比较重要.后面从示例中慢慢加深理解.</description>
    </item>
    
    <item>
      <title>和
浅析</title>
      <link>http://leaver.me/2013/04/05/%E5%92%8C-%E6%B5%85%E6%9E%90/</link>
      <pubDate>Fri, 05 Apr 2013 13:29:04 +0000</pubDate>
      
      <guid>http://leaver.me/2013/04/05/%E5%92%8C-%E6%B5%85%E6%9E%90/</guid>
      <description>这两个转义字符最初学习C++的时候看到了,当时没多想，后来某一天突然想起来，回车不就是换行吗？这不是多此一举吗？今天又看到，索性查了下相关资料，整理一下，留作记录.
关于“回车”（carriage return）和“换行”（line feed）这两个概念的来历和区别。
在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行（这句的意思是把纸向上拉，然后打印头就定位到了下一行），可以想象一下，这个打印头只能在一个固定的水平线上左右移动，而不能上下移动，我们通过移动纸来完成打印下一行。
不明白的我在youtube上找到一个这种打字机的演示视频，为了方便读者观看，我提供一个下载地址。
后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
Unix系统里，每行结尾只有&amp;rdquo;&amp;lt;换行&amp;gt;&amp;quot;，即&amp;rdquo;\n&amp;rdquo;；
Windows系统里面，每行结尾是&amp;rdquo;&amp;lt;换行&amp;gt;&amp;lt;回车&amp;gt;&amp;quot;，即&amp;rdquo;\n\r&amp;rdquo;；
Mac系统里，每行结尾是&amp;rdquo;&amp;lt;回车&amp;gt;&amp;quot;，不过mac基于unix，所以换行也应该是可以的。
一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。这个如果你在windows下使用vim也会发现这个情况
用C++来说明
如：
 最后只显示 bystander 而 leaver.me 背覆盖了
\n 是换行，系统会将其替换成回车＋换行 把光标 先移到 行首 然后换到下一行 也就是 下一行的行首拉
则 显示
leaver.me
bystander
一句话，这看起来是一个历史遗留问题&amp;hellip;&amp;hellip;</description>
    </item>
    
    <item>
      <title>操作系统的死锁和内存管理</title>
      <link>http://leaver.me/2013/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sat, 02 Feb 2013 06:58:09 +0000</pubDate>
      
      <guid>http://leaver.me/2013/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AD%BB%E9%94%81%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>这部分是最后一部分笔记。《现代操作系统》第三版的笔记就这样了。 死锁； 把需要排他性使用的对象称为资源，资源分为可抢占的和不可抢占的。可抢占资源可以从拥有它的进程中抢占而不会具有任何副作用。存储器就是可抢占的。不可抢占资源是指在不引起相关的计算失败的情况下，无法把它从占有她的进程处抢占过来。比如CD刻录机，如果一个进程开始刻盘，突然分配给CD刻录机到另一进程，就会划坏CD盘。死锁会发生在不可抢占资源中 死锁的规范定义：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。
死锁的四个必要条件 1.互斥条件。每个资源要么已经分配给一个进程，要么就是可用的。 2.占有和等待条件，已经得到了某个资源的进程可以再请求新的资源。 3.不可抢占条件，已经分配给一个进程的资源不可强制性的被抢占，他只能由占有她的进程显式的释放。 4.环路等待条件。死锁发生时，系统中一定有友两个/多个进程组成的一条回路，该环路中的每个进程都在等待着下一个进程所占有的资源。
死锁处理的四种策略 1.忽略该问题，如果可以忽略。则忽略 2.检测死锁并恢复，让死锁发生，检测他们是否发生，一旦发生。采取行动。 3.仔细对资源进行分配。动态的避免死锁。 4.通过破坏引起的四个必要条件之一。防止死锁发生。
银行家算法就是对每个请求进行检查。检查如果满足这一请求是否会达到安全状态，或是，那么满足这请求，若否。就推迟这一请求的满足。为了看状态是否安全。类似于银行家投资。看自己是否有足够的资源满足客户。如果可以。就认为投资是可以收回的。接着检查最接近最大限额的一个客户。如果所有投资最终都被收回。则该状态安全。
通信死锁：两个/以上的进程发送消息通信。A向B发送请求信息，然后阻塞直到B回复。假设请求信息丢失，A将阻塞等待回复。B则阻塞等待一个向其发送命令的请求。则发生死锁。他不能通过对资源排序/安排调度来避免，因此。采用了超时来中断通信死锁。
活锁：两个进程A和B，A获得1.B获得2.轮询请求对方的。没有进程被阻塞。看起来像是死锁发生了。就叫做活锁。
内存管理 每个linux进程都有一个地址空间，逻辑上有三段组成：代码。数据和堆栈段。代码段包含了形成程序可执行代码的机器指令。通常是只读的。是由编译器把源码转换成机器码形成的。 数据段包含了所有程序变量。字符串。数字和其他数据的存储。由两部分，初始化数据和未初始化数据。后者即为BSS，符号起始块。加载后被初始化为0.数据段可以修改。可以增加数据段的大小。 第三段是栈段。大多数机器里。从虚拟地址空间的顶部/附近开始。并且向下生长。
linux内存由三部分组成。前两部分是内核和内存映射，被钉在内存中。页面从不换粗。内存的其他部分，被划分为页框。每个页框都可以包含一个代码。数据或栈页面。
window如何知道系统配置的细节呢。答案就是windows会挂载一种特殊的文件系统，其为小文件做了优化，到名字空间，也就是注册表。注册表被阻止成了不同的卷，称作储巢。hive。一个叫做system的储巢会在系统启动时。装入内存。这里面包含了驱动什么设备工作。什么软件要初始化。那些变量等等。</description>
    </item>
    
    <item>
      <title>ubuntu终端su认证失败解决</title>
      <link>http://leaver.me/2012/04/15/ubuntu%E7%BB%88%E7%AB%AFsu%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Sun, 15 Apr 2012 18:09:10 +0000</pubDate>
      
      <guid>http://leaver.me/2012/04/15/ubuntu%E7%BB%88%E7%AB%AFsu%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3/</guid>
      <description>这个以前碰到过。不过今天又遇到了。记录一下。Ubuntu 安装后，root用户默认被锁定，不允许登录，也不允许“su”到 root。对于开发人员来说貌似有些麻烦了。。
　解决方法：打开终端。输入sudo passwd 回车，然后输入安装ubuntu时设置的密码。回车后要求输入新密码。新密码可以和安装时的密码相同。所以继续输吧。然后确认一次。就可以了
　
然后正常su root 就可以切换到root了</description>
    </item>
    
    <item>
      <title>lamp开发环境简单搭建</title>
      <link>http://leaver.me/2012/04/15/lamp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sun, 15 Apr 2012 17:54:27 +0000</pubDate>
      
      <guid>http://leaver.me/2012/04/15/lamp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</guid>
      <description>因为一些事情，要去学习php开发。所以呢。今天就先搭建一下php开发环境，其实windows下搭建相对比较简单，也有一键安装包。比如AppServ，但是因为考虑到以后的一些事情，于是还是采用LAMP开发环境。
　我是用Ubuntu来做，本地刚好有Ubuntu的镜像。。虚拟里面来测试。首先就是在虚拟机里安装Ubuntu。这个不多说。大家都会。安装好以后。登陆进来。命令行或是图形界面都可以。
　新版本的Ubuntu貌似是没了新立得管理器。所以使用命令来安装更简单。打开终端。切换到root。如果不能切换到root。参考此文。切换到root后。输入
　回车后就开始自动下载了。大概几分钟后就会出现MySql的安装设置界面
 输入你想设置的mysql的登录密码。然后需要再输入一遍
 ok。等会就安装完成了。。就这么简单。。 然后进行一些后续的设置
　默认网站的目录在/usr/www.这个目录的权限如下图。 
　为了以后方便。设置为777会更好一些。。执行如下命令：
 然后是启用 apache的 mod_rewrite 模块 输入如下命令：
　然后继续输入如下命令来重启 Apache服务器：
　Apache重启后我们可以测试一下，在 /var/www目录下新建文件 test.php，写入代码： 保存，在地址栏输入 http://127.0.0.1/test.php 或 http://localhost/test.php ，如果正确出现了如下 php 配置信息则表明 LAMP Apache已经正常工作了 
　还可以测试一下mysql是否正常。这个直接在终端下输入
　然后根据提示输入密码就出现如下的图  表示已经登录到mysql了。说明mysql可以了。可以继续输入 show databases;来显示所有的数据库。 
参考文章：http://blog.csdn.net/xiaojianpitt/article/details/6326834</description>
    </item>
    
  </channel>
</rss>