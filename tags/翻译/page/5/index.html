<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Overview of all pages with the tag #翻译 - bystander&#39;s blog</title>
  <meta property="og:title" content="Overview of all pages with the tag #翻译" />
  <meta name="twitter:title" content="Overview of all pages with the tag #翻译" />
  <meta name="description" content="Overview of all pages with the tag #翻译, such as: [译]使用Mockito简单mock入门">
  <meta property="og:description" content="Overview of all pages with the tag #翻译, such as: [译]使用Mockito简单mock入门">
  <meta name="twitter:description" content="Overview of all pages with the tag #翻译, such as: [译]使用Mockito简单mock入门">
  <meta name="author" content="bystander"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "bystander\x27s blog",
    
    "url": "https:\/\/leizhiyuan.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/leizhiyuan.github.io\/"
  
  
  
  
}
</script>

<meta property="og:title" content="翻译" />
<meta property="og:image" content="https://leizhiyuan.github.io/images/author.jpg" />
<meta property="og:url" content="https://leizhiyuan.github.io/tags/%E7%BF%BB%E8%AF%91/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="bystander&#39;s blog" />

  <meta name="twitter:title" content="翻译" />
  <meta name="twitter:image" content="https://leizhiyuan.github.io/images/author.jpg" />
  <meta name="twitter:card" content="summary" />
  <link href='https://leizhiyuan.github.io/images/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://leizhiyuan.github.io/images/author.jpg" />
  <meta name="twitter:image" content="https://leizhiyuan.github.io/images/author.jpg" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://leizhiyuan.github.io/tags/%E7%BF%BB%E8%AF%91/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="bystander&#39;s blog" />

  <meta name="generator" content="Hugo 0.61.0" />
  <link rel="alternate" href="https://leizhiyuan.github.io/index.xml" type="application/rss+xml" title="bystander&#39;s blog"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://leizhiyuan.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://leizhiyuan.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://leizhiyuan.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://leizhiyuan.github.io/">bystander&#39;s blog</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="首页" href="/">首页</a>
            </li>
          
        
          
            <li>
              <a title="目录" href="/categories">目录</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        
          
            <li>
              <a title="友情链接" href="/2016/01/01/links">友情链接</a>
            </li>
          
        
          
            <li>
              <a title="关于我" href="/about/">关于我</a>
            </li>
          
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="bystander&#39;s blog" href="https://leizhiyuan.github.io/">
            <img class="avatar-img" src="https://leizhiyuan.github.io/images/author.jpg" alt="bystander&#39;s blog" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="tags-heading">
              
                <h1>翻译</h1>
              
              
                <hr class="small">
              
              
              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
  <div class="container" role="main">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        
        <div class="posts-list">
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/09/27/%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%8F%91%E7%94%9F%E6%97%A0%E6%95%88%E7%9A%84%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8/">
                <h2 class="post-title">从数据库读取图片发生“无效的参数”异常</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on September 27, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  <h3 id="heading">介绍</h3>
<p>我发现对于很多人来说，当从数据库里载入一张图片然后重新创建成一张图片显示的话会有这样一个问题&mdash;-当他们尝试重新创建新的图片的时候，会抛出一个“无效的参数”异常</p>
<p>因此，本文介绍该异常如何产生。并且我希望未来当我或是你发生这个错误的时候还能有所帮助。。</p>
<h3 id="heading-1">背景</h3>
<p>存储图片到数据库里面是一个很有效的想法。很多人在一些场合都会这样做。的确，这是一个很好的想法。在图片很小的情况下，或者图片不是太多。在这两种情况下，当你需要图片的时候，你会实时去加载它们。而当你不需要的时候如果从数据库里加载图片会浪费很多带宽。并使得你的程序有一些慢。</p>
<p>但问题是这种方法也很容易发生错误。&ndash;尤其是你使用字符串连接，然后组合到你的SQL语句里面—并且这个错误只有当你打算使用存储的信息的时候才会发生。然后，看起来似乎是你的读取代码写错了&mdash;不可能—它是正常的。我在其他地方都可以的。。</p>
<h3 id="heading-2">从数据库里加载图片</h3>
<p>重数据库里读取一张图片然后转换成图片显示是很简单的。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>将会抛出一个异常—无效的参数</p>
<p>只有当你真正看了从数据库里返回到data里的数据-而不是简单的瞄了一眼调试器，你才能注意到是什么原因。。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>它看起来不像是错的，所以它可能就是你想要的。-虽然21字节是一个很大的线索：你的图片可能只有21字节长？那图片可真小。。</p>
<p>但是，上面的是可以读懂的。。稍微练习一下。。每个字节是一个ASCII码。。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>简而言之，你从数据库里得到的数据是一个人类可以读懂的字符串，意思是是</p>
<!-- raw HTML omitted -->
<p>当这个Image类试图把它转换成一个图片的时候，必然是不可能的。抛出异常就是必然的了。。代码是正确的。data才是问题所在。</p>
<h3 id="heading-3">保存图片到数据库</h3>
<p>这才是引发问题的地方。
通常。这是因为把字符串连接起来构造SQL语句引起的。</p>
<!-- raw HTML omitted -->
<p>不要在SQL语句中包含image对象—它会调用Image的ToString方法。而这个方法会返回</p>
<!-- raw HTML omitted -->
<p>因此你的上一条语句其实就相当于</p>
<!-- raw HTML omitted -->
<p>存储并不会有什么问题—但是事实上只是把Image的类型名保存了。而你傻傻的以为是图片数据本身。</p>
<p>这还不是唯一的一个不让你直接连接字符串构造SQL语句的原因，如果你想知道其他原因。
使用Google 搜索Bobby Tables，&mdash;这不是闹着玩的。。</p>
<p>好了。其实把代码写正确也不难，虽然可能得多花一些时间。但是，它可以帮助提高代码的可读性和可靠性。而你要做的就是使用一个参数化的查询。</p>
<p>首先，把图片转换到一个字节数组里。</p>
<!-- raw HTML omitted -->

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/c/">C＃</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%A4%A7%E5%AD%A6/">大学</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E8%BD%AF%E4%BB%B6/">软件</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/09/27/c#%E4%BD%BF%E7%94%A8graphics%E5%88%9B%E5%BB%BA%E9%A5%BC%E5%9B%BE/">
                <h2 class="post-title">C#使用Graphics创建饼图</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on September 27, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  <h3 id="heading">介绍</h3>
<p>这个程序是使用C#中的Graphics来创建一个饼图的，我已经尽我所能写的很好了。如果你有任何建议可以分享给我，这样我也能从中学习。</p>
<h3 id="heading-1">使用代码</h3>
<p>最近我迷上了Graphics类。我仅仅体验了一下Graphics的DrawPie() 和FillPie() 方法。</p>
<p>最为一个简单的Demo，我创建一个有着五个文本框的窗体，一个按钮，一个图片框。一会我就把饼图画在图片框里</p>
<p><a href="http://leaverimage.b0.upaiyun.com/27557_o.png"><img src="/images/f3681994ca4fce2b724886db9d7a958d854c8e39.png" alt="" title="client"></a>
在创建一个饼图之前，我们头脑里要有这个意识。我们不能创建一个不符合常规的圆，创建圆我们需要度数信息。</p>
<p>为了转换度数。我们首先把给定的值做个求和。然后得出文本框里所有值的和。然后呢。用每个值除以总值再乘以360度。
代码如下：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>值转换完毕后。我们可以创建Graphics类的实例了。</p>
<!-- raw HTML omitted -->
<p>然后我们需要创建一个矩形区域，在这个矩形区域里绘制饼图。</p>
<!-- raw HTML omitted -->
<p>前两个参数定义了矩形左上角的坐标，后两个分别定义了举行的宽和高。</p>
<p>为了能够比较清晰的看出饼图各部分的比例。我们需要创建五个笔刷。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>现在我们可以开始创建我们的饼图了。graphics.FillPie();方法接受四个参数</p>
<ol>
<li>笔刷，用来填充扇形</li>
<li>矩形：饼图将被创建的区域。</li>
<li>开始角度：饼部分的开始角度</li>
<li>覆盖角度：饼部分扫过的角度</li>
</ol>
<p>一般来说graphics.FillPie();方法并不是创建一个完全的饼图，而是创建饼图的一个扇形部分，我们会创建一系列的扇形最终看起来像是一个饼图。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>上面代码的第一行将会创建第一个红色的扇形。起点是0度，并且创建一个计算好的扇面。
之后，在第二行，我们的扇面的起点就会接着上一步的结束的位置，也就是deg1 ，第二行，我们的起点就会是 deg1+deg2</p>
<p>这段代码如你所见，可能不是最优的。我们创建了五个不同的笔刷。和不同的浮点数，而这些操作可以用循环完成。。</p>
<p>我故意没有这样做。因为，这样做了就可能使问题复杂化。下面是使用循环和数组完成相同的工作。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><a href="http://leaverimage.b0.upaiyun.com/27558_o.png"><img src="/images/341f6010ffe346f8245bdae48986ae61c6dfe90f.png" alt="" title="listbox"></a>
首先我创建一个整型数组，数组元素个数等于列表框里的数目。然后我使用一个循环计算了所有值的和。
然后。我创建了一个颜色的数组，这里我建议不要创建一个多于6个扇形。。不然看起来就连在一起了。。
第三步呢。。我再次使用循环去把值转换成度数。fDegValue 用来保存每次计算的度数。在我们前面的例子里。我们需要把前面几个值加起来作为下一个扇形的开始。而这里。我们使用fDegSum 来保存前面的和就很好了。</p>
<p>本文很简单，也就使用Graphics创建一个饼图而已。如果是要创建一些专业的图表就要用到.net提供的图表控件了。</p>
<p>下载：<a href="http://pan.baidu.com/share/link?shareid=63681&amp;uk=1493685990">源代码和Demo</a></p>
<p>原文地址：<a href="http://www.codeproject.com/Articles/463284/Create-Pie-Chart-Using-Graphics-in-Csharp-NET">Create-Pie-Chart-Using-Graphics-in-Csharp-NET</a>
著作权声明：本文由<a href="http://leaver.me">http://leaver.me</a> 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</p>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/c/">C＃</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/windows/">windows</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%A4%A7%E5%AD%A6/">大学</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/09/26/avalondock-2.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/">
                <h2 class="post-title">AvalonDock 2.0入门指南第一部分</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on September 26, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  AvalonDock 2.0可以用来为WPF创建一个类似Visual Studio的界面，深入理解如何使用AvalonDock进行开发是很重要的。
在这个入门指南里，我将演示如何开始使用AvalonDock，下面的文章都是基于2.0版本的。并且不能用于早期的版本。
AvalonDock是一个组合的布局模型，很多的控件都在视图上显示，一个DockingManager 类也显示在停靠区，用于可以拖拽文档和工具。
从下面这个截图中我们可以理解AvalonDock组件
 DockingManager 这是AvalonDock中的核心控件，它将包含的窗格排序，处理飞出的窗格，还有浮动的窗口。在上面这个图中，DockingManager 对象包含了所有空间（WPF控件），从顶部的工具栏到底部的状态栏都算。同时。DockingManager 也可以处理保存和恢复布局。
LayoutPanel 这个面板用来管理在一个方向上的子窗口（通过Orientation属性来选择方向），并且在它们之间添加了一个大小调节控件，在一个Orientation属性是Horizontal（水平）的LayoutPanel 上，排列了三个窗格。一个LayoutAnchorablePane在左，一个LayoutDocumentPane在中间。一个LayoutDockablePane在右边。
LayoutDockablePane 这个布局元素包含一个LayoutAnchorable对象的集合。通过它用来管理想TabControl这样的控件，在上面的截图中，LayoutDockablePanes是在左边的'Strumenti&rsquo; 和 &lsquo;Progetti&rsquo; (工具和项目) 和在右边的'Classi&rsquo; 和 &lsquo;Proprieta&rsquo;&rsquo; (类视图和属性视图)的容器，一个LayoutDockablePane可以自动隐藏，就像'Errori&rsquo;(错误)和'Lista Azioni&rsquo;(操作列表) and &lsquo;Uscita&rsquo;(输出)。并且LayoutDockablePane可以被拖动到DockingManager上，成为一个浮动窗口或者附着到它的父控件DockingManager的边缘上。
LayoutDocumentPane 通常包含文档（DocumentContent类型）的一种窗格，但是其实也可以包含像上面提到的工具视图和类视图这样的DockableContents。在一个文档里。LayoutDocumentPane 被放置在ResizingPanel（水平方向）里。ResizingPanel则是上卖弄提到的在两个DockablePane中间的区域。注意。文档窗格是不能被移动的。
LayoutAnchorable 一个停靠内容，是软件控件的容器，总是被包含在一个窗格里（LayoutAnchorablePane或是LayoutDocumentPane），在截图里。LayoutAnchorable是一类对象（包含一个SharpDevelop对象），工具对象，但是错误窗口（它处于自动隐藏状态，被好办在一个自动隐藏窗格里）不是。LayoutAnchorable就像它名字所暗示的那样。可以被从他的容器窗格里拖走。然后重新放置在一个存在的窗格里。或者是放置在父DockingManager的边缘，或者是放置在一个浮动窗口里（LayoutAnchorableFloatingWindow）。
LayoutDocument 是一个仅可以被寄宿到LayoutDocumentPane的内容。它是一个特殊的内容，因为不能被停靠到边缘。仅能被放置到LayoutDocumentPane里。或者浮动在一个LayoutDocumentFloatingWindow窗口里。在途中，DocumentContent对象是program.cs&rsquo; 或 &lsquo;MainForm.cs&rsquo; 文件视图
**LayoutFloatingWindow **，是一个包含内容的窗口，当被拖动到一个DockingManager上面的时候，LayoutFloatingWindow（LayoutAnchorableFloatingWindow和LayoutDocumentFloatingWindow继承自他）集成在Window，总是包含一个窗格（LayoutAnchorablePane或是LayoutDocumentPane），窗格包含更多的内容（LayoutAnchorable或LayoutDocument），当用户对一个内容或是DockablePane执行拖拽，或者直接手工使用代码调用LayoutContent.Float()方法 LayoutFloatingWindow就被直接从DockingManager创建出来了。
LayoutPane 一个基类，LayoutDockablePane和LayoutDocumentPane继承自它。它为他们提供了一些共有的属性和方法。
LayoutContent 是LayoutAnchorable 和LayoutAnchorable类的父类。提供了共有的属性和方法。
理解布局元素是一些属于布局模型的类而不是属于视图是很重要的。因为，他们不是继承自FrameworkElement类，取而代之。AvalonDock包含了另一些类来展示这些组件的视图。这些类通常被命名为相关联的类名+Control字串。举个例子，在布局里创建的LayoutAnchorable创建了一个LayoutAnchorableControl（继承自FrameworkElement的类），并且绑定了LayoutAnchorableControl.Model 到这个LayoutAnchorable对象上。
每一个被创建的视图控件总是有着Model属性的布局元素。因此，重新设计一个相关视图控件的样式是可以的。
为了开始创建一个新的.net 4/.net 4.5的解决方案。并且添加对AvalonDock.dll的引用（可以直接添加也可以使用NuGet），然后添加AD命名空间到MainWindow.xaml中。
在根Grid下放置DockingManager组件和一个简单的布局。
DockingManager是AvalonDock的核心类，他的责任就是创建管理布局。布局被定义成一个ILayoutElement的树。树的根由LayoutRoot类指定。LayoutRoot由一些基本的子树来构成。。
1.根面板的 根属性指向主 LayoutPanel，也是LayoutRoot的内容属性。
2.大体上讲，RightSide/LeftSide/TopSide/BottonSide是LayoutAnchorGroup对象的集合属性，他们表示了停靠管理器的四个边。停靠管理器的锚通常是隐藏的。当用户移动鼠标到这些区域的时候。就会在自动隐藏的窗口里显示出来。
3.FloatingWindows属性是FloatingWindow的集合。一个浮动窗口当用户拖动一个窗格（LayoutAnchorable或是LayoutDocument）的时候就被创建出来，这个集合可以被AvalonDock自动更新，但是用户依然可以通过调用LayoutContent的Float()方法来创建一个浮动窗口。
Hidden是一个Anchorable（停靠）对象的集合。默认情况下，当用户点击一个LayoutAnchorable对象的关闭按钮，AvalonDock隐藏它：通过从布局里移除停靠元素，并且把他放入Hidden集合，当用户想要再一次显示的时候，AD又把这个内容从隐藏集合里删除重新显示在他被隐藏的那个窗格里。
当使用布局树的时候，程序员可以创建任何复杂的界面，LayoutAnchorablePane的DockWidth和DockHeight属性可以被用来设置窗格的初始宽度和高度。而LayoutDocumentPane类通常则填满可用的空间。AvalonDock管理内容元素的宽度和高度以使得可以使用所有的可用空间。因此如果一个LayoutAnchorablePane被放置在一个LayoutPanel里，为LayoutAnchorablePane使用一个固定尺寸而为LayoutDocumentPane使用一个比例长度。也就是说为停靠对象使用了比例长度。
一个LayoutDocumentGroup/ LayoutAnchorableGroup类可以被用来包含更多的LayoutDocumentPane/ LayoutAnchorablePane，举个例子，让我们来改变上面的例子来实现更复杂的例子。
运行这个工程你就可以重新排列内容了。移动他们到浮动窗口。为了更加熟悉AvalonDock，我建议你多试几次，然后重新排列内容实现更复杂的布局。
在入门指南的第二部分。我将演示我们如何保存布局。附加事件像DocumentClose/ DocumentClosing 或者ActiveContent 改变的事件。 原文地址：AvalonDock 2.0 getting started guide PART 1 著作权声明：本文由http://leaver.
                  <a href="https://leizhiyuan.github.io/2012/09/26/avalondock-2.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/c/">C＃</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/wpf/">WPF</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%A4%A7%E5%AD%A6/">大学</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%AD%A6%E4%B9%A0/">学习</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/09/25/c#%E7%BC%96%E5%86%99youtube%E4%B8%8B%E8%BD%BD%E5%99%A8/">
                <h2 class="post-title">C#编写youtube下载器</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on September 25, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  <h3 id="heading">介绍</h3>
<p>本文将会暂时如何仅仅使用C#来下载youtub视频，代码简单也容易理解，每个人都可以把它整合到自己的工程项目里。</p>
<p>我没有使用任何第三方的库来完成这段代码，你所要做的仅仅是把两个.cs文件整合进你的项目里。</p>
<h3 id="heading-1">使用代码</h3>
<p>这个工程里有两个主要的类</p>
<p>YouTubeVideoQuality Class（youtube视频质量类）</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>YouTubeDownloader Class(youtube下载类)</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="heading-2">有趣的地方</h3>
<p>使用这个代码，你可以根据你的网速来选择不同品质的视频来下载</p>
<p>许多人网速很慢他们不能在线看youtube，因为我写了这个代码帮助这些人来下载视频到他们的PC上。这样，他们就能离线看了。。</p>
<h3 id="heading-3">许可</h3>
<p>本文。包括源代码和文件，在CPOL下授权。</p>
<p>原文地址：<a href="http://www.codeproject.com/Tips/323771/YouTube-Downloader-Using-Csharp-NET">YouTube-Downloader-Using-Csharp-NET</a>
著作权声明：本文由<a href="http://leaver.me">http://leaver.me</a> 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</p>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/c/">C＃</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%A4%A7%E5%AD%A6/">大学</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BC%96%E7%A8%8B/">编程</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/09/24/.net%E6%98%BE%E7%A4%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%9B%BE%E6%A0%87/">
                <h2 class="post-title">.net显示网络连接状态图标</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on September 24, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  <p>效果图：
<a href="http://leaverimage.b0.upaiyun.com/27419_o.jpg"><img src="/images/" alt="" title="internet connection"></a></p>
<h3 id="heading">介绍</h3>
<p>　　越来越多的软件要通过连接互联网来执行一些业务层的业务操作，比如调用web services服务，获取数据等等。
通常你可能希望知道当前你的网络连接是不是真的连上了，当然有很多种方法可以做到，比如，你可以查看System.Net 命名空间中的NetworkInterface 的状态，但是有这以太网连接并不表示你的连接真的可以用。 本文将会展示一种方法，该方法在程序的状态栏StatusStrip 显示一个简单的图标来指示是不是真的连接到了互联网。</p>
<h3 id="heading-1">使用代码</h3>
<p>　　最简单的我们会想到使用一个Timer来进行http-get请求来判断一个特定的网页是否可用。</p>
<p>　　当然这种方法下，我们最应该考虑的就是请求不能阻塞UI线程，因此，我将使用一个BackgroundWorker 对象来进行get请求，BackgroundWorker 对象声明了DoWork方法。该方法定义了一个事件句柄，该句柄传递一个DoWorkEventArgs 类来将事件的处理结果返回到UI线程，因此，你不必与任何的UI元素进行交互，因为它运行在一个独立的线程里。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>　　这个查询很简单，我执行简单的HttpWebRequest 来请求一个必然是可用的网页。比如微软的主页或是Google的主页。通过这样，我们就能知道是不是真的连接上了互联网。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>　　当BackgroundWorker 对象完成了他的工作，，也就是定义DoWork 里的事件，他会触发RunWorkerCompleted 事件，这个事件也定义了一个定制的事件句柄- RunWorkerCompletedEventArgs 有了这个类，我们就可以管理ToolStripStatusLabel的显示了</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="heading-2">结论</h3>
<p>　　.net 是的使用后台线程很容易，也是的我们的UI有了更加平滑，有好的体验，现在，VS2005强烈建议手工为DoWork指定你的代理 ，因为VS.net有一个bug，当你尝试着重写而不是在另一个独立的线程里使用UI代码，VS可能会替换你写的代码。。
如果你需要使用Web Service，也许你可以考虑添加一个GetVersion的方法到你的Web Service里。然后尝试去访问这个服务。来确定你的web服务器是不是正常可用。</p>
<h3 id="heading-3">历史</h3>
<p>　　Demo  version - 1.0.0.0 –随文附
<!-- raw HTML omitted -->许可<!-- raw HTML omitted -->
　　本文没有显式的许可，但是可能包含了一些使用上的条款，不论是在文章里还是在下载的代码里。如果有疑问联系我吧。。</p>
<p>原文地址：<a href="http://www.codeproject.com/Articles/11045/Display-an-Internet-Connection-status-icon-using-N">Display an Internet Connection status icon using .NET Framework 2.0</a></p>
<p>著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</p>
<p>源代码下载：<a href="http://pan.baidu.com/share/link?shareid=61578&amp;uk=1493685990">InternetConnectionStatus</a></p>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/c/">C＃</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/windows/">windows</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%8E%9F%E5%88%9B/">原创</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%A4%A7%E5%AD%A6/">大学</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E8%BD%AF%E4%BB%B6/">软件</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/09/24/%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%AE%9A%E5%88%B6%E7%9A%84wpf%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%AF%9D%E6%A1%86/">
                <h2 class="post-title">一个可定制的WPF任务对话框</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on September 24, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  今天实在看WPF揭秘的时候看到TaskDialog这个控件的。然后就去找了一下开源的代码。在codeproject上发现了这个，非常给力。。另外codeproject改版后很漂亮哦。 
介绍： 这是用WPF实现Vista上TaskDialog效果的代码。
Messagbox消息框 通过调用重写的静态Show方法。TaskDialog就会表现的像一个Messagebox。他有四个文本类型的属性：Header（头部）, Content（内容）, Detail（更多）, 和 Footer（底部），其实Detail是一个折叠的区域， 而Header和Footer还有一个icon属性（HeaderIcon和FooterIcon），除此之外，Header还有Background（背景）和Foreground（前景）属性
TaskDialog控件派生自HeaderedContentControl类，因为从HeaderedContentControl类可以获得Header和Content属性，TaskDialog仅仅是添加了Detail和Footer属性，这些属性是Object类型，并且有他们自己的template（模板）属性HeaderTemplate, ContentTemplate, DetailTemplate, 和 FooterTemplate)，TaskDialog类对于文本内容有着缺省的数据模板，当然你也可以用那四个模板来替换，这样你就可以以你喜欢的任何方式来格式化文本了。下面这个图展示了通过斜体和下划线来格式化文本。
 图2
因为Header，Content，Detail和Footer是object类型，因此不再受到只能是文本的限制了，你可以防止你喜欢的任何类型到TaskDialog，下面这个例子中的TaskDialog是不是很像UAC的提示呢。这里Content属性是一个UserControl类型，放置了一个图片和一些文本还有两个CommandButtons（都是普通的按钮。。不过添加了一些定制的样式，再加了Header属性）
 图三
一个模拟vista的文件拷贝窗口的TaskDialog。。
 图四
额外的一些有意思的属性 下面是TaskDialog暴露的属性列表（按字母表排序） Button1Text: string类型，当TaskDialogButton属性被设置为Custom的时候，用来设置按钮的文字 Button2Text: 同上 Button3Text: 同上 DefaultResult: TaskDialogResult类型. 设置缺省的按钮 IsButton1Enabled: bool类型. 获取或设置按钮的Enabled状态 IsButton2Enabled: 同上 IsButton3Enabled: 同上 IsCloseButtonEnabled: bool类型. 获取或设置窗口关闭按钮的Enabled状态 (缺省为false) IsExpanded: bool类型，获取或是设置Detail部分的可见性。 IsModal: bool类型，获取或是设置对话框是不是模态的 ShowInTaskBar: bool类型，获取或是设置对话框是不是显示在任务栏中 SystemSound: TaskDialogSound类型. 设置当对话框显示的时候播放的声音 TaskDialogButton: TaskDialogButton类型. 显示在对话框上的按钮可以是None, Ok, OkCancel, YesNo, YesNoCancel, or Custom (查看上面提到的按钮设置) title: string类型，对话框的标题 ToggleButtonTexts: TaskDialogToggleButtonTexts提供了两个属性来设置toggle按钮的这个属性，当toggle 按钮折叠或是展开的时候 (缺省是'Show Details&rsquo; 和'Hide Details&rsquo;).
                  <a href="https://leizhiyuan.github.io/2012/09/24/%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%AE%9A%E5%88%B6%E7%9A%84wpf%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%AF%9D%E6%A1%86/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/c/">C＃</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/wpf/">WPF</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%AD%A6%E4%B9%A0/">学习</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E6%80%BB%E7%BB%93/">总结</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E6%94%B6%E8%97%8F/">收藏</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/05/23/c-%E7%8B%AC%E7%AB%8B%E5%BC%95%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88/">
                <h2 class="post-title">C&#43;&#43; 独立引用，为什么？</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on May 23, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;2&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  问题：
I read in some good C++ tutorial that independent references do exist, and act like aliasing. 我读了一些好的C++文章，发现独立引用确实存在，并且很像别名。 But&hellip; I wonder what it is made for. 但是，，，我想知道他适用于什么情况。 Why should one want to use aliasing.Besides, some piece of code that is not clear to me: 为什么有人想使用别名呢，另外，下面这段代码我不太清楚。
First, ref is a &lsquo;reference&rsquo; to a.I understand from second line of code that address for ref (hence the ampershead) is 首先，ref是一个对a的引用，从第二行代码那我认为ref的地址也就是a，（括号里面不清楚什么意思。貌似是作者写错了）
a. Then, integer ref is assigned the value of b (19).
                  <a href="https://leizhiyuan.github.io/2012/05/23/c-%E7%8B%AC%E7%AB%8B%E5%BC%95%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/%E6%80%BB%E7%BB%93/">总结</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BC%96%E7%A8%8B/">编程</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/05/22/c-c-%E4%B8%ADsizeof%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8D%E5%90%8C/">
                <h2 class="post-title">c &amp; c&#43;&#43;中sizeof返回值不同?</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on May 22, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  问题: A character array is defined globally and a structure with same name is defined within a function. 一个字符数组被定义为全局变量，一个相同名字的结构体被定义在一个函数内部。
Why sizeof operator returns different values for c &amp; c++ ? 为什么sizeof操作符对于C和C++返回了不同的值呢？
答案： Because in C++, the struct you defined is named S, while in C, 因为在C++中，你定义的结构体的名称是S，而在C中，
it's named struct S (which is why you often see typedef struct used in C code). 他叫做struct S（这也是为什么我们可以经常看到typedef struct 被用在C代码中）。
In C, to refer to the struct type, you need to say struct S.
                  <a href="https://leizhiyuan.github.io/2012/05/22/c-c-%E4%B8%ADsizeof%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8D%E5%90%8C/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/stackoverflow/">stackoverflow</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%8E%9F%E5%88%9B/">原创</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E6%80%BB%E7%BB%93/">总结</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BC%96%E7%A8%8B/">编程</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://leizhiyuan.github.io/2012/05/21/%E4%B8%BA%E4%BB%80%E4%B9%88sizeofstr.substr03.c_str8/">
                <h2 class="post-title">为什么sizeof(str.substr(0,3).c_str())=8?</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on May 21, 2012
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;bystander
    
  
  
</span>


              </p>
              <div class="post-entry">
                
                  问题： string str = &quot;abcdefgdcb&quot;; cout &amp;lt; &amp;lt; sizeof(str.substr(0,3).c_str()); For some reason, the above string is giving me 8. I assumed c_str() returns a null string, 由于某些原因，上面的这个字符串得到的结果是8，我估计c_str()返回了一个null，
and sizeof uses the null to determine the size of the string. 并且sizeof函数使用这个null来定义这个字符串的大小。
答案： Because sizeof doesn't give you the length of a string, 因为sizeof给你的不是一个字符串的长度，
it gives you the size of the type (const char * in this case). Try strlen. 他给你的是这个类型的大小（这种情况下的类型是c_str()返回的const char*类型），想要得到正确的结果，试试strlen函数吧。
                  <a href="https://leizhiyuan.github.io/2012/05/21/%E4%B8%BA%E4%BB%80%E4%B9%88sizeofstr.substr03.c_str8/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%8E%9F%E5%88%9B/">原创</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E5%BC%80%E5%8F%91/">开发</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BC%96%E7%A8%8B/">编程</a>&nbsp;
                  
                    <a href="https://leizhiyuan.github.io//tags/%E7%BF%BB%E8%AF%91/">翻译</a>&nbsp;
                  
                </div>
              

            </article>
          
        </div>
        
          <ul class="pager main-pager">
            
              <li class="previous">
                <a href="https://leizhiyuan.github.io/tags/%E7%BF%BB%E8%AF%91/page/4/">&larr; Newer Posts</a>
              </li>
            
            
          </ul>
        
      </div>
    </div>
  </div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="https://github.com/leizhiyuan" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="/tags/%E7%BF%BB%E8%AF%91/index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="leaver.me">bystander</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2019
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://leizhiyuan.github.io/">bystander&#39;s blog</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.61.0</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://leizhiyuan.github.io/js/main.js"></script>
<script src="https://leizhiyuan.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://leizhiyuan.github.io/js/load-photoswipe.js"></script>









  </body>
</html>

