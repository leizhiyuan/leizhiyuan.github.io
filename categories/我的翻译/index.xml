<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>我的翻译 on bystander&#39;s blog</title>
    <link>http://leaver.me/categories/%E6%88%91%E7%9A%84%E7%BF%BB%E8%AF%91/</link>
    <description>Recent content in 我的翻译 on bystander&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 01 Mar 2014 10:57:33 +0000</lastBuildDate>
    
	<atom:link href="http://leaver.me/categories/%E6%88%91%E7%9A%84%E7%BF%BB%E8%AF%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[译]使用Mockito简单mock入门</title>
      <link>http://leaver.me/2014/03/01/%E8%AF%91%E4%BD%BF%E7%94%A8mockito%E7%AE%80%E5%8D%95mock%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 01 Mar 2014 10:57:33 +0000</pubDate>
      
      <guid>http://leaver.me/2014/03/01/%E8%AF%91%E4%BD%BF%E7%94%A8mockito%E7%AE%80%E5%8D%95mock%E5%85%A5%E9%97%A8/</guid>
      <description>我们在写单元测试的时候，面临的一个挑战就是要测试的内容总是依赖于其他组件，要是我们还得先配置好其他组件，未免有点不如意，那么我们可以使用Mocks来代替那些依赖的组件
本文问了展示这个过程，我会创建一个DAL，数据访问层，这是一个类，提供了一个通用的api来访问和修改数据仓库的数据，然后，我们要测试这个api，而不用配置连接某个本地的数据库，，或者一个远程的数据库，或者是一个文件系统，反正就是任何放数据的东西，DAL层的好处就是隔离开了数据访问和应用程序代码
首先使用maven来创建一个工程
执行之后，本地生成MockitoDemo 文件夹，然后整个工程的目录结构与生成好了。
然后，我们写这样一个model类，表示book类型
然后，我们访问Book model的DAL类会如下
DAL层现在还没啥功能，我们要通过TDD来测试，实际中，DAL可能和ORM来交互，也可能和数据库API交互，但是我们设计DAL的时候，不用关心
准备测试
我倾向于用junit做单元测试，而Mockito做mock。首先更新一下pom文件。添加依赖
下面，我们要测试啦，我们会在单元测试中把mock数据注入到BookDAL中，这样我们就不要依赖任何数据源就可以完成测试
我们当然对应测试DAL类的每个方法嘛。
然后我们会在setup（这个方法是在测试类执行测试前执行的，用于准备数据啦）
在setup()方法中
1.首先我创建BookDAL的对象
2.然后stub,存根。。用mock的数据。这样当对应的方法被调用的时候就返回我mock的数据
然后，我们执行一下
mvn test就可以看到结果了
   很简单。。。没有配置任何实际的数据源。</description>
    </item>
    
    <item>
      <title>前路月光</title>
      <link>http://leaver.me/2014/01/28/%E5%89%8D%E8%B7%AF%E6%9C%88%E5%85%89/</link>
      <pubDate>Tue, 28 Jan 2014 15:35:43 +0000</pubDate>
      
      <guid>http://leaver.me/2014/01/28/%E5%89%8D%E8%B7%AF%E6%9C%88%E5%85%89/</guid>
      <description>火影片头曲想知道中文，没找到翻译，于是译之，感谢@sepith  。
今夜月光 不知为何 比往日温柔 崎岖泥泞的来时路 何时才能有同行之人
我沉默 为即将而来的眼泪 泪水中努力 悲伤着变得更强
很多时候，伤痕累累 忘掉了痛苦 流过血泪 王者归来是使命所及 哪管一路秋叶萧萧
我仰望星空 孤独从来不是虚假的幻想 你的过去我无法参与 我想要的的是现在和未来
昨日月光 无论是明亮，还是黯淡 我用双手铸造 始于生而终于死 一定错过了 诸多美好
我的同伴 虽然时过境迁 可是，你住过的地方 经年难忘 如果你想对我说 我还是会在你身边 舍命相陪
很多时候，伤痕累累 星空暗淡 假使黎明 也悄然消失 我一定再一次 为了梦想努力拼搏
痛到难以承受 迷惘前路崎岖 我轻轻闭上双眼 感受月光温柔 前路相伴 岂敢轻易迷失
如果欺骗了内心 失去了自己 莫忘星空璀璨 凝视遥远的未来 固执地努力
很多时候，伤痕累累 忘掉了痛苦 流过血泪， 王者归来是使命所及 哪管一路秋叶萧萧
我仰望星空 真正强大的是 心怀梦想的人 有着爱的人</description>
    </item>
    
    <item>
      <title>Spring依赖注入</title>
      <link>http://leaver.me/2013/09/20/spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Fri, 20 Sep 2013 19:06:00 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/20/spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid>
      <description>在Spring框架中，依赖注入设计模式主要用来定义对象之间的依赖，存在两种主要类型
1)setter注入(设置器)
2)constructor注入(构造器)
1.Setter注入 是最流行最简单的DI方法，通过一个setter方法来完成依赖。
例子：
一个有一个setter方法的Helper类
再写一个bean配合iwenjianshengming这些bean，并且通过property(属性)标签来设置依赖
看到了把。我们只需要一个setter方法把CsvOutputGenerator注入进去就行了
2.Constructor注入 这种方式是通过一个构造函数来完成依赖设置的
例子：
一个有着一个构造函数的Helper类
然后当然是一个bean配置文件了。通过constructor-arg标签来写依赖
该选哪个？ 没有硬性规定，哪个合适就用那个，由于setter的简单性，一般还是setter用得多。</description>
    </item>
    
    <item>
      <title>Spring松耦合示例</title>
      <link>http://leaver.me/2013/09/20/spring%E6%9D%BE%E8%80%A6%E5%90%88%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Fri, 20 Sep 2013 15:50:46 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/20/spring%E6%9D%BE%E8%80%A6%E5%90%88%E7%A4%BA%E4%BE%8B/</guid>
      <description>面向对象设计的理念是把整个系统分成一组可重用的组件，然而，当系统变得越大的时候，尤其是在java中，这最大的对象依赖将会紧紧耦合，以至于非常难以管理和修改，而现在，你可以使用Spring框架扮演一个中间模块的角色，方便高效地管理其他组件依赖
输出生成的例子 看个例子，假设你的项目有一个方法可以输出内容到csv或者json格式，你可能写出这样的代码
，然后是实现接口的类
再写个Json生成的类
有好几种方法来调用IOutputGenerator接口，以及我们如何使用Spring来避免对象的过度耦合。
方法1-直接调用 问题：
这种方法，output这个对象和CsvOutputGenerator耦合在了一起，每次要改变输出格式的话都要修改代码，如果这类代码遍布项目，那么改起来就跪了
方法2-通过帮助类调用 也许你会想创建一个Helper类吧所有的output实现都移进去
然后可以这样调用
问题：
看起来似乎更加优雅了，你仅仅需要管理这个Helper类就可以实现不同格式的输出需求改变了，然而，Helper还是和CvsOutputGenerator耦合，每一次要改变输出格式的时候，都要对Helper类做一下微调。
方法3-Spring Spring依赖注入很合适，可以使不同的格式生成类分离开来
首先对OutputHelper做一点微调，添加了一个参数
然后创建一个Spring bean配置文件，并声明所有的Java对象依赖
然后通过Spring调用
以后要改Json格式，直接改一下xml配置文件就行了。能够减少错误
结论 通过Spring框架的依赖注入，可以优雅的管理对象依赖，更大的灵活性，尤其是对于Java项目非常好用。</description>
    </item>
    
    <item>
      <title>Spring3实例入门-Hello World</title>
      <link>http://leaver.me/2013/09/20/spring3%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8-hello-world/</link>
      <pubDate>Fri, 20 Sep 2013 13:14:39 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/20/spring3%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8-hello-world/</guid>
      <description>每次看到hello world,都有一种说不出的赶脚，想起了一个程序员，退休后写毛笔字，取笔研磨铺纸，大笔一挥，写下了“hello world”。
1.使用Maven生成项目结构 2.转换成Eclipse项目 3.添加Spring3.0 依赖 在pom.xml文件里添加Spring 3.0 依赖，然后依赖会从Maven中央仓库自动下载
4.Spring bean 写个简单的bean
5.Spring bean配置文件 创建一个配置文件，在里面声明所有可用的Spring beans
6.最终的目录结构 
 7.运行 8.输出 9.Demo下载 Spring3-hello-world-example.zip</description>
    </item>
    
    <item>
      <title>使用Maven创建Web项目</title>
      <link>http://leaver.me/2013/09/20/%E4%BD%BF%E7%94%A8maven%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Fri, 20 Sep 2013 08:44:11 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/20/%E4%BD%BF%E7%94%A8maven%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</guid>
      <description>本文通过Maven完成一个简单的Web项目（注意，Spring配置不是重点，看看就行）
1.从Maven模板创建Web应用程序 命令格式如下：
这就告诉Maven从**maven-archetype-webapp **这个模板来创建
友情提示：是不是太难记了..好吧，直接输入
根据向导来创建把。。
比如我这样写：
就创建了一个包名为com.mkyong,类名为CounterWebApp的项目了
2.Maven的Web程序目录结构 标准的web.xml部署描述文件生成了
对结构有疑问的去这里
生成的pom.xml文件如下
没啥疑问的。web.xml文件则如下：
index.jsp内容是：
3.转换以支持Eclipse 为了使Maven的web项目支持Eclipse，在命令行下，cd到CounterWebApp目录下，然后输入这个命令
-Dwtpversion=2.0参数是必需的，这个参数指明了是web项目，然后导入到eclipse里就行了。从导入的工程ico可以看出是个web项目
图一
  
不要迷惑，如果我们只输入
会转换成java项目，而不是web项目的。
好了，现在项目已经准备好部署了，eclipse里的tomcat server插件装好，然后启动项目
图二

可以通过_http://localhost:8080/CounterWebApp/_地址来访问
4.更新pom文件 为了使Maven项目支持Spring MVC框架，我们需要修改pom.xml文件
1.添加编译插件指定jdk6来编译
2.添加Spring框架依赖
3.升级JUnit到4.1.1
5.Spring MVC 松耦合 创建Spring MVC控制器类，有两个方法，打印信息
然后，创建Spring配置文件，定义视图解析器
然后更新一下web.xml文件，通过Spring的监听器ContextLoaderListener把Spring框架集成进去
然移动index.jsp到WEB-INF目录里，以防用户直接访问他，同时我们编辑，增加${message}变量，也就是controller控制器传过来的值到页面
最终的页面结构是：
图三

6.Eclipse+Tomcat 为了通过Eclipse的Tomcat插件开始/调试项目，需要再执行一次下面的命令，使得所有的依赖附加完成
在没执行以前，项目依赖是空的
图四

执行完以后，就都有了
图五

重要！许多人就是没有第二次执行这个命令导致无法开始/调试，如果有问题，右击你的项目属性，看看依赖是否为空
7.Maven打包 web项目打包成war。放在target目录
进入项目目录，执行一下就可以了
然后把target目录的CountWebApp.war文件拷贝，并部署到你的web容器里就行了
8.Demo演示 打开_http://localhost:8080/CounterWebApp/welcome_
可以看到
图六

我们传个参数进去
http://localhost:8080/CounterWebApp/welcome/mkyong
就可以看到效果了
图七

9.Demo下载
CounterWebApp.zip</description>
    </item>
    
    <item>
      <title>Maven库依赖机制及添加自定义库</title>
      <link>http://leaver.me/2013/09/19/maven%E5%BA%93%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93/</link>
      <pubDate>Thu, 19 Sep 2013 22:49:42 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/19/maven%E5%BA%93%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%93/</guid>
      <description>一.Maven库依赖机制 Maven的库依赖机制可以帮助我们自动下载依赖的库文件，并且还能更新版本。。
考虑一个情境来理解机制的工作原理，假设我们要使用Log4J库作为项目的日志记录。以下是我们要做的
1.传统的方式 1）访问Log4J网站http://logging.apache.org/log4j/2.x/
2）下载Log4J的jar包
3）复制进项目的classpath里
4）手工包含到项目的依赖里
看到没，你要从头做到尾，如果Log4J更新了，你得再来一遍。。
2.Maven的方式 1）需要知道Log4J的Maven坐标(coordinates,这个暂时没想到好名字)，就是这样的东西
然后Maven就会自动下载1.2.14版本的Log4J了。如果version这个元素没有，那么如果有了新版本，Maven会自动下载新版本的。
2）在pom.xml里声明这个Maven坐标
3）当Maven编译或者build的时候，Log4J会自动下载，放入本地仓库里
4）Maven全部接管
3.解释 搜索顺序前面说过了。本地-》中央-》远程仓库
Maven坐标咋来的，当然去中央仓库搜索之了，搜索结果清晰的令人发指
二.添加自定义库到本地仓库 有两个情况，需要我们包含自定义的库到本地仓库里
1是你想使用的jar文件不再中央仓库
2是你创建了一个自定义的jar包，需要另一个项目使用这个jar
比如，kaptche，一个第三方的java库，生成验证码，现在中央仓库没有了。
我们想要加到本地仓库里
1.mvn安装 下载kaptche，解压并且拷贝kaptcha-version.jar到其他任何你喜欢的地方，比如c盘，然后输入如下格式的命令
这里我这样输入
这样完成了。kaptcha已经存在本地库了
2.pom.xml配置一下 这个前面说过了，Maven坐标嘛</description>
    </item>
    
    <item>
      <title>Maven仓库详解</title>
      <link>http://leaver.me/2013/09/19/maven%E4%BB%93%E5%BA%93%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 19 Sep 2013 22:05:10 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/19/maven%E4%BB%93%E5%BA%93%E8%AF%A6%E8%A7%A3/</guid>
      <description>本文由我翻译合并了多篇文章，整理成一篇。
一.本地仓库(Local Repository) 本地仓库就是一个本机的目录，这个目录被用来存储我们项目的所有依赖（插件的jar包还有一些其他的文件），简单的说，当你build一个Maven项目的时候，所有的依赖文件都会放在本地仓库里，仓库供所有项目都可以使用
默认情况下，本地仓库在.m2目录，windows下的话就是你的用户名目录下的.m2目录
1.更新本地仓库目录 找到你的MAVEN_HOME目录下的conf/setting.xml文件，更新localRepository节点
2.保存一下 完成了。新的本地仓库被放在了D:/maven/repo
看一下这个目录

二.中央仓库(central repository) 当我们build一个Maven项目的时候，Maven会检查我们的pom.xml文件，来定义项目的依赖，然后Maven会在本地仓库里查找，如果没有找到，就去maven的中央库去下载，地址是
http://search.maven.org/#browse
看起来是这样的

 注意啊，虽然这个是新的中央仓库，但有时候还是会从_“**http://repo1.maven.org/maven/**_这个旧仓库下载东西，不过不要紧，理解就行了
三.远程仓库(Remote Respository) 在Maven中，当你在pom.xml中生命的依赖既不在本地库，也不在中央库的时候，就会报错。
1.例子 org.jvnet.localizer这个包仅在java.net的仓库里有(以前是，现在中央仓库也有了。但理解就行)
  </description>
    </item>
    
    <item>
      <title>Maven安装教程</title>
      <link>http://leaver.me/2013/09/19/maven%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 19 Sep 2013 21:15:09 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/19/maven%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</guid>
      <description>Maven不需要作为服务组件安装到windows上，仅仅需要下载，解压，然后配置一下环境变量就行了
1.JDK和JAVA_HOME 确保JDK已经安装，同时JAVA_HOME变量已经添加到了windows环境变量里，指向jdk目录

 2.下载Maven 去Maven主页,选个版本，点击下载
3.解压 解压下载的zip文件，重命名，比如我放到D盘的Maven目录
4.添加MAVEN_HOME环境变量 添加一个新的环境变量MAVEN_HOME到环境变量，指向Maven目录

 5.添加path变量 更新Path变量，把Maven的bin目录添加进去，这样就可以在任何地方执行mvn命令了

 6.验证 打开命令行，输入
如果看到类似下面的
Maven已经成功的安装配置了。
老外写的太详细了。。。
 </description>
    </item>
    
    <item>
      <title>Maven实例入门-随机数生成</title>
      <link>http://leaver.me/2013/09/19/maven%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90/</link>
      <pubDate>Thu, 19 Sep 2013 20:50:23 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/19/maven%E5%AE%9E%E4%BE%8B%E5%85%A5%E9%97%A8-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90/</guid>
      <description>看了很多个例子，发现这个最好，译文中会带有我的一些了理解，有问题欢迎指出。
0.Maven是什么？ Apache Maven，是一个软件（特别是Java软件）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。
可以看到，核心就是项目管理和自动构建了，从例子中将会体会更深。本例创建一个随机数生成程序。
1.从Maven模板创建项目 Maven的环境变量配置和java类似，直接添加系统变量MAVEN_HOME指向你下载的maven目录，然后将bin目录添加到path环境变量里。
在命令行下，进入到你想存储项目的位置，比如，我自己有个叫work的目录，那么我就cd到work目录，然后按下面的格式输入命令
这是告诉Maven从**maven-archetype-quickstart **创建一个java项目，如果你这个参数不填，那么会列出一个列表，让你选择你想创建什么类型，比如web项目啊，啥的。
友情提示：是不是太难记了..好吧，直接输入
根据向导来创建把。。
比如
这里的groupId就是包名，artifactId就是类名，以后具体的一些其他参数我希望有时间可以跟大家分享。
2.Maven目录结构 上面的命令第一次执行的时候会从apache网站下载maven的一些其他东西，所以务必保持联网。执行成功后，会生成一个这样的目录结构
这里main目录是我们的程序住代码目录。源代码会放在/src/main/java/包名 目录里，而单元测试代码会放在/src/test/java/包名 目录里。当然还有一个标准的pom.xml文件会生成。这个pom文件其实类似于Ant的build.xml文件，它包含了项目的信息，从目录结构到项目插件到项目依赖，都有了。。
3.用Eclipse写代码 maven已经生成了一个完整的工程了，为了能够导入到eclipse里来编辑代码，我们可以把这个项目转换成eclipse可用的。
首先命令行进入NumberGenerator目录，然后输入
然后就会生成Eclipse需要的所有项目文件里
图1.导入eclipse之后的效果

4.更新pom文件 默认的pom文件太简单了。通常我们需要添加编译插件来告诉Maven我们打算使用哪个版本的jdk来编译项目，有时候默认的版本太低了
我们把source和target改成了1.6.
然后更新JUnit到4.1.1
最终我们的pom文件如下
5.更新业务逻辑 TDD开发的理念告诉我们先写测试，我们打开AppTest.java文件。
然后修改App.java的代码
6.Maven打包 现在，我们要使用Maven来编译我们的项目，并且打包成一个jar文件，记得pom.xml文件吗？在这个文件里我们定义了打包的类型
在项目目录(也就是NumberGenerator目录)的命令行下，输入
然后就会看到：
程序开始编译，并且执行了单元测试，然后在target目录下生成了jar包，最后，程序目录结构如下：

7.执行Demo 运行生成的jar文件，还在在NumberGenerator目录下，输入如下命令
后面的com.mkyong.App就是包名+类名，也就是类的全名了
8.Demo下载 Maven-NumberGenerator.zip
 基本上一个完整的的示例就做完了，希望你有所收获，后续会更新一些Maven的的东西。欢迎支持。中秋快乐。
  </description>
    </item>
    
    <item>
      <title>[译]Java中的CountDownLatch和CyclicBarrier</title>
      <link>http://leaver.me/2013/09/15/%E8%AF%91java%E4%B8%AD%E7%9A%84countdownlatch%E5%92%8Ccyclicbarrier/</link>
      <pubDate>Sun, 15 Sep 2013 08:03:09 +0000</pubDate>
      
      <guid>http://leaver.me/2013/09/15/%E8%AF%91java%E4%B8%AD%E7%9A%84countdownlatch%E5%92%8Ccyclicbarrier/</guid>
      <description>本文译自官方文档，有细微改动，Java多线程的时候，看了好多文档，还是官方说的最清楚。结合自己的理解，译之。
CountDownLatch 字面意思就是倒计数闩，后面会讲到，这里的同步允许一个或多个线程等待，，知道其他线程进行的一系列操作完成。而CountDownLatch通过一个参数count（数目）来构造，而await（）则阻塞当前线程，直到countDown()将count减为了0，然后，所有的阻塞线程被释放，也就是那些调用了await方法的线程立即返回，注意，这是一次性的，也就是说count不能被自动重置，如果你想这么做，CyclicBarrier是可以的。
CountDownLatch用处很多，当用count=1来构造的时候，这就相当于一个开关，所有调用了await方法的线程都在等待，直到有一个线程调用了countDown()，CountDownLatch通过count=N构造的话，就可以使一个线程等待其他N个线程完成操作，或者一个操作被做N次。
简单的demo：
一组worker（工人）线程使用两个CountDownLatch
第一个是开始信号，用来阻止工人提前操作，直到(driver)传送带准备好了才允许开始
第二个是完成信号，他使传送带等待直到所有的worker都完成
另一个典型的例子就是把问题分成N部分，通过线程执行每一部分，具体的话是将线程入队到一个Executor对象里。然后调用execute方法。当执行完毕一部分，就并给latch 减去1，当减到0的时候调用await的方法就可以继续运行了，当需要重复计数的话，用CyclicBarrier代替
 CyclicBarrier 字面意思回环栅栏。这里的同步是允许一系列的线程互相等待直到大家都来到一个barrier前面，当程序中有互相等待的情况的时候，非常有用，叫做回环是因为当所有等待线程都被释放以后，cyclicBarrier可以被重用
同时，CyclicBarrier支持一个可选的Runnable参数，当所有的线程都来到barrier前面的时候，程序开始执行runable线程动作，当需要更新所有线程共享的某个状态的时候，该动作非常有用。例子是一个并行分解的例子
这里每一个worker线程处理矩阵的一行，然后在barrier前面等待，直到所有的行都处理完成，当所有的都完成以后，这里
改为
如果一个线程由于中断，失败或者超时过早的离开了barrier，那么所有的线程都会通过BrokenBarrierException引发异常。</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第八篇–CSV文件操作</title>
      <link>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87csv%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 11 Aug 2013 16:55:33 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AF%87csv%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>本文作为sed使用教程的最后一篇，将比较全面的讲解如何操作csv文件，csv文件通过逗号分隔
示例文件如下：
1.删除第一列s开启替换模式，当^符号在中括号里的时候，就是非的意思，也就是说[^,]匹配了所有不是逗号的一个字符，然后后面的星号表示0个或多个，然后是一个逗号，也就是匹配&amp;quot;xxxx,&amp;ldquo;替换为空
2.删除除过最后一列的其他所有sed先匹配任意多个字符，然后匹配最后一个“,”这就直接把前面的都匹配完了。替换为空即可。
3.输出第一列好理解把，先匹配第一列之后的逗号，然后是多个字符，然后替换为空
4.删除第二列先匹配第一列之后的逗号，然后匹配一个或多个非逗号字符，这样就匹配了第二列的内容，然后再匹配一个逗号，我简化一下，比如该列是1，2，3，4，那么这一个匹配就是&amp;rdquo;,2,&amp;quot;，替换成一个逗号，就是1，3，4了
5.输出第二列我们可以分析前两个斜线之间的内容
两个右斜线转移了括号，所以括号不是简单的符号，而是正则里的组的意义，圆括号的作用是对字符进行分组，并保存匹配的文本。这里先匹配非逗号的多个字符，然后一个逗号，然后再匹配第二列，并且第二列的匹配用括号括起来，然后匹配其他列，然后里面用\1来引用这个括号的内容，如果前面有两个括号，就可以使用\1或\2这样，分别表示第一个括号或第二个括号的匹配
6.输出最后一列是一位数字的行.*匹配了前面的所有字符，然后,匹配了最后一个逗号，sed的贪婪原则。。然后[0-9]匹配一个数字$表示行尾.ok
7.给每一行自动添加行号这个和cat -n file的效果是一样的。awk也可以很简单的做，这里使用一个=命令会在每一行之前添加一个行号，也就是是，如果执行
文件会是：
然后我们通过管道再执行
N表示读入并合并下一行，然后将两行之间的换行符替换为空即可了
8.如果第一列是Ubuntu，就把最后一列替换成99中间的
匹配“Ubuntu,任意个字符,任意个字符”,也就是将行分成几组，将本行替换成第一组的内容第一组的内容，第二组的内容，但最后的一列被替换成99，就这样。
9.如果第一列是RedHat就删除第二列也好理解嘛。将要保留的用括号分组，然后用\1和\2分别引用第一组和第二组，然后中间的匹配就被删除了
10.在末尾插入一列正则首先匹配了整行字符，然后使用&amp;amp;来引用该匹配，然后添加了一个逗号和一个A
11.在头部添加一列
很简单不是么&amp;hellip;
比预计的要快，两天翻译完了.体会到了理解原理对学习sed的好处，希望对想学的人有帮助.
          </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第七篇–输出文件内容(10 Demo)</title>
      <link>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AF%87%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B910-demo/</link>
      <pubDate>Sun, 11 Aug 2013 16:27:31 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/11/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AF%87%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B910-demo/</guid>
      <description>之前已经学习过选择性打印输出了，本文将通过10个例子全面讲解文件输出的一些方法，主打p命令
首先看一下将使用的示例文件
1.打印文件首行之前讲过了，-n取消默认的全部打印，p表示print，1就是行号了
2.输出最后一行3.输出不匹配X的那些行也好理解，！表示非，就是说包含X匹配的不打印输出
4.输出包含u/x的那些行正则是强大的，这样就匹配了u/x
5.输出以x/X结尾的那些行这里$符号不再是匹配文件尾部，而是行尾，这是正则的规则
6.输出以A/L开头的行前面也说过，^匹配了行首，A表示A匹配，然而|则是或者的意思，为什么要加\转义，是为了避免被解析成pipe管道，后面的就不解释了
7.隔行打印n命令是输出当前行，然后读入下一行到pattern space的意思，这句命令是这么执行的，首先读入一行，然后通过n命令输出，然后通过n命令再读一行，然后把这行删除，就出现了隔行输出的效果
8.如何两行输出，隔两行再输出n;n; 命令呢输出了前两行，然后读入第三行到pattern space，N命令则对如下一行并与第三行合并，然后d命令删除pattern space中的内容，于是三四行被清空，然后读入56行，继续重复。就这样。作者这里给出的例子不直观，我举个例子，我的文件内容是
执行上面的命令后，会输出
明白了吧
9.输出某个范围行内以X结果的那些行这里首先制定了从/Unix/匹配开始到文件尾部的这些行，然后呢，在这些之间的行，如果以X结果，就输出。
10.输出不包括开始和结尾的那些行这个命令就会只输出/Solaris/和/HPUX/之间的行，不包括他们两个。
这里要说一下//这个，当匹配了Solaris的时候就进入了花括号，因为这个里面没有提供任何匹配，所以就考虑最后一次匹配模式，也就是相当于是考虑Solaris这一行，他不被打印，当到了HPUX这一匹配，//又代表了HPUX匹配，这一行也不打印。
Demo完了，你懂了么。</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第六篇–删除文件内容</title>
      <link>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AF%87%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Sat, 10 Aug 2013 13:15:38 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AF%87%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>其实，删除和替换是由一些相同的，不过，这里我们单独列出来，通过25个例子穿插讲解sed删除文件的一些方法，使用的示例文件如下：
1.删除第一行d就是删除，1就是指第1行，记得哦，这不会影响到源文件，一般，做删除的时候一般要加-i参数，前面说过了
2.删除指定行，这里删除第3行3.删除最后一行4.删除范围行，这里删除2-4行5.保留指定的行，这里保留2-4行！这个是对前面的2,4来操作，是非的意思，也就是不是2-4行的行，这样除去2-4行，其他的都删除了
6.删除第一行和最后一行分号隔开两个命令，你懂的，也可以删除第二行和第三行等等. &amp;lsquo;2d;3d&amp;rsquo;
7.删除以指定字符开头的行这里就把以L开头的Linux这一行删除了
8.删除以指定字符结尾的行这里就删除了，可以看到AIX没有删除，unix区分大小写你懂的
9.忽略大小写，都删除[xX]匹配x或X，所以就成功了嘛
10.删除文件中的空行^匹配开头，$匹配结果，中间啥都没有，这样就匹配了空行，但是注意哦，如果某一行全是空格，这个命令是不会删除这一行的。
11.删除空行或是仅仅包含空格的行如果你看我前面的文章，这个就不用我说了吧，0个或多个空格就是匹配了所有的空行了
12.删除完全是大写字母的行[A-Z]就匹配了26个大写字母的任意一个
13.删除包含Unix匹配的行14.删除不包含Unix的行15.删除包含Unix或Linux匹配的行这里要说的是|，这个本来是表示or，或的意思，但是在终端下，为了防止被认为是管道，所以要用\来转义
16.删除从第一行到满足匹配的行可以通过行号到模式，模式到行号等等组合来匹配
17.删除从Linux匹配到末尾的行18.如果最后一行匹配AIX就删除，否则就不删除$匹配了最后一行，也可以是行号，比如1，后面的大括号里就是条件和处理方式了，这样就在sed里实现了if条件了，再看一遍这个例子，熟悉一下这个规则
19.所处最后一行如果满足两个匹配20.如果1-4行满足Solaris匹配就删除21.删除包含Unix匹配的行，同时删除下一行N命令将下一行读入pattern space，什么。你忘了，看开篇去，这个命令就删除了两行
22.删除包含Unix的下一行作者这里没有说清楚，我讲一下，N读入了下一行，然后这时候pattern space里就相当于两行并作了一行，中间有一个换行符，所以pattern space里现在就是：
然后通过s命令匹配了\nLinux，并且替换为空，就ok了哦。
23.删除包含Linux模式的行，也包含上一行少年，不要怕，我们一步步来
首先，要知道，为了删除某一匹配的前一行，我们需要将文件的每一行放入到hold space里，一旦发现匹配，我们就开始删除连个缓冲区的内容，其中pattern space存储了当前行，hold space 存储了前一行
而x;p;这是啥呢，这两个命令是对每一行都会执行的，x表示exchange，即是交换hold space 和pattern space中的内容，p则是print，打印pattern space中的内容，因此，每次当前行被存入hold space，然后打印出了前一行的内容
当/Linux/匹配之后，我们使用s/.//来清空当前行，也就是pattern space为空了，当前行相当于被删了，然后使用x和hold space来交换，这样，就导致hold space为空了，然后使用d来删除pattern space的内容（此时pattern space里是交换过来的前一行的内容），因此，匹配Linnx的当前行和前一行都被删除了，
然后呢${x;p;}表示如果最后一行还在hold space里，就把他换出来，打印出来。
而后面的管道之后的命令呢，是吧第一部分sed命令之后产生的空行给删掉。
再理解一下
24.仅删除匹配Linux的前一行，不删除当前行和23类似，当匹配到Linux的时候，hold space 存储了前一行的内容，所以我们交换一下他们，然后前一行就进入了pattern space，然后一个d，这样就把前一行删掉了。别急，还没完，这样，当前行就被留在hold space了。就无法被输出了
1h;1!{x;p;} 1h是说，如果将第1行移动到hold space，也就是1h只对第一行操作，而后面的1!{x;p;}是说对于其他的行执行x;p;命令，
25.删除匹配模式的前后两行有了前面两个例子，自己试试理解一下，有问题留言讨论吧。</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第五篇–替换文件内容续</title>
      <link>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%AD/</link>
      <pubDate>Sat, 10 Aug 2013 09:05:55 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%BB%AD/</guid>
      <description>前面已经学习过替换文件内容了，本文我们学习一些更频繁使用的搜索替换操作.
示例文件使用：
1.替换每行开始的两个字母，这里用XX来替换s代表substitute，前面说过了，^用来匹配行开头，.表示任意一个字符，两个..就是你懂的，
其实，不要^符号也是可以的，因为默认就是从开头开始匹配，如下也可以实现
2.删除每行开头的两个字符看到没有，后两个斜线之间没有内容，也就是用空字符来替换开头的两个字符，就实现了删除
3.要是想删除每行最后的两个字符呢再次强调，$在不同的情况下表示不同的意思，这里匹配行尾，有时候也匹配文件尾部
4.向每行末尾添加内容这里，先匹配行尾，然后把&amp;rdquo;.Rs&amp;quot;添加到行尾
5.在每行开头添加空格还记得前面说过的么，sed默认不影响原始文件，要是想更新原始文件，请加-i参数
6.移除开始的空格^匹配行首，然后是一个空格，然后是*，表示一个或多个空格嘛，然后替换为空字符
7.移除行首和行尾的空格不要怕，从分号处分开，就是两条命令啦，一个做行首的，一个做行尾的，前面说过的，可以使用-e参数来分开
8.如何在一个字符串前后添加一些其他字符呢，可以用来字符串转义前两个斜线匹配了所有字符，也就是本行，然后后面两个斜线是替换的内容，注意里面的&amp;amp;符号，之前也说过的，表示匹配到的字符，也就是本行了。所有就这样啦
9.移除行首和行尾的一个字符（多个你也会的啦）分开看看，你可以的
10.删除第一个数字之前的所有字符这条命令略复杂，请先回头看一下我们的示例文件，然后我们开始分析这个表达式，地一个^表示匹配行首，然后[^0-9]* 是一个典型的正则，匹配非数字的多个字符，简单说一下[0-9]表示匹配0,1,2,3,4,5,6,7,8,9任意一个字符，前面加个一个^，表示非，也就是不匹配这些数字，然后最后是一个*，表示匹配非数字的连续多个字符，有机会的话我会推荐一个正则系列，或者自己写一篇文章。这里就先这样理解吧。
那猜猜这个是干嘛的
是的，你猜对了，删除开头的所有非字母字符。
11.删除行尾的数字看看前面的你就知道了
12.通过分隔符得到文件最后一列可能你你预想的不一样，是不是，你可能认为会是第一列被删除，其他的列都在，不对的，sed是很贪心的，当我们指定&amp;rsquo;.*:&amp;lsquo;时，他会一直向后查找，尽量匹配更多，所以，就匹配到最后一个列之前了
13.转换整行字符为小写\L是sed的一个命令，Lowercase嘛。\L之后的内容被毁转换，而&amp;amp;表示前面匹配道德内容，所以就实现了转换
14.转换大写\U你懂的，Uppercase
  </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第四篇–选择性打印</title>
      <link>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87%E9%80%89%E6%8B%A9%E6%80%A7%E6%89%93%E5%8D%B0/</link>
      <pubDate>Sat, 10 Aug 2013 08:39:56 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/10/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AF%87%E9%80%89%E6%8B%A9%E6%80%A7%E6%89%93%E5%8D%B0/</guid>
      <description>本文，我们将会学习如何选择性的打印（其实，这里的打印是print，也就是输出到标准输出的意思），用到的示例文件是：
1.打印所有内容一对单引号，没有任何参数即可
2.如何打印包含Gmail的那一行.(grep也可以实现这个功能)在斜线里面，我们指定正则匹配模式，p的意思呢，就是print，打印的意思，也就是打印包含Gmail这一行，但是我们看到Gmail打印了两次，为什么，因为sed的默认行为是在解析完一行之后就把他输出出来，也就是对于Gmail这一行，先执行p解析，解析完成后再默认打印一次，就打印了两次，而其他的，没有命令解析，直接读入完成后输出即可。
如果得到期望的结果呢？
-n参数会取消sed的默认打印行为，所以就ok了
3.删除包含Gmail的那一行。（grep -v也有同样的效果）d就是delete的意思，不多解释，
同样，要想删除某一指定的行
4.打印直到模式匹配，这里我们从头一直打印到Yahooq就是quit的意思，这条命令就是对于前面的行都没啥可解析的，执行默认的打印即可，一到碰到Yahoo这一行，打印完成，就停止，退出，因此，就是上面的了
打印某一指定范围行
到此，我们一直在学习基于一个条件取一行或多行，现在，我们来学习打印指定范围行
使用的示例文件如下：
5.打印前三行-n先取消默认打印，然后1,3指定行范围，p表示打印，你想一下我们前面的q命令，就知道下面这个命令效果是一样的
执行默认打印，到第三行的时候退出
6.通过模式指定范围，这里我打印从Yahoo到Live之间的行，包括本身不用多解释了
7.从指定模式到文件尾部，这里是从Redif到文件尾回忆一下$符号吧.少年
8.从开头到匹配模式相信你懂的&amp;hellip;
对于数字不需要斜线包围，对于匹配需要斜线.就这样..
  </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第三篇–读写文件</title>
      <link>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 09 Aug 2013 16:52:56 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AF%87%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</guid>
      <description>本文将展示如何将文件内容读入到sed输出，同时包含如何将一个文件的部分内容写入到另一文件
一.文件读取
假定有两个文件，file1和file2，内容分别如下：
sed有两个选项用来读写文件
看例子：
1.在file1的每一行读完之后读取file2的内容r file2读取file2的所有内容，因此r之前没有知道那个行号或匹配，因此有了上面的输出，记住，sed的工作机制，每次读file1的一行，然后执行命令
2.如何在读取了file1的第一行之后将file2读入r前面加个1就行了
3.当file1某行匹配了模式之后，读入file2sed逐行读入file1，然后判断该行是否匹配banana，如果匹配，就读入file2
4.当file1读取完成后读入file2，其实就是合并两个文件这里只是演示一下，其实cat file1 file2就可以完成合并
_**二.文件写入**_使用一个file1文件，内容如下：
1.将file1的2-4行写入到file22,4w就是写2-4行的意思，那-n呢？默认情况下sed会把读入的文件处理的结果输出到标准输出，也就是终端，而为了不使用默认输出，-n就派上用场了，执行该命令终端不会有任何输出
查看file2内容，发现已经写入成功了
2.从第三行开始全部写入file2就不多解释了
3.如果是用正则呢？该命令将逐行读入file1，然后判断该行是否匹配apple，如果匹配，则作为起始行，然后继续读入，判断是否匹配mango，如果是，则作为终止行，然后将中间的内容写入到file2
 </description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第二篇–替换文件内容</title>
      <link>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</link>
      <pubDate>Fri, 09 Aug 2013 16:24:12 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</guid>
      <description>上一节中-Unix sed实用教程第一篇–向文件中增加一行 学习了添加文件，本节讲解数据内容替换.
本节将使用sample1.txt文件作为示例，文件内容如下，都是些水果..：
1.向每一行的开头添加内容，这里我们添加“Fruit：”
解析：s代表substitution，也就是替换，s之后是要替换/匹配的内容，斜线/用来分隔s以及要替换的原始内容还有要替换的最终内容，而&#39;^&#39;符号是说一个正则，用来匹配每一行的开头，匹配成功后在开头加上&#39;Fruit:&#39;。
2.向每一行的行尾添加内容
注意，这里的$和上一节的$符号表示的意义不同，这里则是表示行尾.
3.如何替换指定的字符，这里将小写a替换成大写A
注意，仅仅将每一行的第一个a替换了，不是所有，本例表示替换单个字符，你可以替换一个单词都是可以的.
4.如何替换行内所有的字符，用A替换a
注意，只是加了一个g选项，g为global的简写，就是全局，全部的意思。
5.如何替换第二次出现的a?
不使用g，而是使用数字来表示行内第几次出现的a，结果如上
6.如何替换第二次之后的所有a呢？
很好理解对吧。
7.如果只想替换第三行的a呢？
回想一下第一节，在执行命令之前，会判断当前address是否满足条件，3就是地址
8.想替换一个范围行内的数据呢
逗号隔开，即可
9.如何替换整行呢？比如用apple is a Fruit替换apple
这里‘&amp;amp;’符号标识了模式匹配到的内容，而.*匹配了正行，.表示任意字符，*表示一个或多个，也就是匹配了整行,&amp;amp;因此就是整行内容，用来重命名一组文件的时候非常有用.
10.如何进行多个替换，比如用A替换a，用P替换p
也就是用分号分开即可。或者也可以通过-e参数来做
-e 选项就是当需要替换多个的时候来用的。
另外，要是替换的太多。也可以通过右斜线来分成多行
相信通过本文实例分析，平时的文件内容替换就很简单了</description>
    </item>
    
    <item>
      <title>[译]Unix sed实用教程第一篇--向文件中增加一行</title>
      <link>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</link>
      <pubDate>Fri, 09 Aug 2013 14:56:29 +0000</pubDate>
      
      <guid>http://leaver.me/2013/08/09/%E8%AF%91unix-sed%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/</guid>
      <description>Unix sed实用教程第一讲，本系列第一篇，有任何问题欢迎留言讨论。
sed 是unix中最重要的编辑器之一，注意，有之一..支持多种编辑任务，本文将实现题目的功能实例
假定我们有一额文本文件，叫做empFile，包含了员工名字和员工id，如下：
1.如何通过sed给文件添加标题行-“Employee, EmpId”解释：数字1，是说只对第一行执行操作，i代表在insert（熟悉vim的同学应该知道，i会在当前字符的前面插入，a是在后面插入），因此，1i就表示在将Employee, EmpId插入到第一行之前，
然后，有了标题行的文件仅仅会输出到标准输出，源文件内容并不会改变，如果需要更新源文件，可以使用重定向输出到一个临时文件，然后移动到原始文件。如果Unix系统的sed是GUN版本的，sed会有一个-i选项，可以直接实现更新源文件，（如何查看版本，终端下输入sed &amp;ndash;version即可看到）下面先执行，再查看文件，发现已经多了标题行了
2.如何在标题行之后，也就是原始第一行之前添加一行横线&amp;ndash;“&amp;mdash;&amp;ndash;”同1，中，1表示第一行，a表示append（附加），也就是说当读入第一行的时候在其之后添加一行，如果你使用2i作为命令也是正确的，就是指当读入第二行的时候，在其之前插入一行。
3.如何在文件尾部添加一行为了在文件尾部插入一行，如果使用之前的方法就需要知道总共有多少行，而$符号则直接指明了最后一行，因此$a表示在读入最后一行的时候，在后面插入一行
4.如何在指定的记录之后插入一条新纪录假定我们的例子文件的内容现在是：
如果我想在Hilesh这个员工之后插入Bharti员工的信息，我这样做：
注意看，我们这里已经不再使用数字或者其他表示行号的标识了，我们使用了一个模式（了解过正则表达式的朋友会比较熟悉，可以理解为某种规则- /Hilesh/a 这个命令表示对于每一行读入的内容，如果发现 /Hilesh/这个匹配，在该行之后插入一行，也就是说如果文件里有两行都是Hilesh员工，那么执行完上面的命令，将会附加两行内容，这里可以想想sed的工作模式，对每一行执行命令条件检测，发现匹配，就执行。
5.如何在指定记录之前插入记录呢，比如，我想在Harshal这条记录之前插入Aparna记录呢？
 </description>
    </item>
    
    <item>
      <title>[译]反射(Reflection)和动态(dynamic)</title>
      <link>http://leaver.me/2013/05/27/%E8%AF%91%E5%8F%8D%E5%B0%84reflection%E5%92%8C%E5%8A%A8%E6%80%81dynamic/</link>
      <pubDate>Mon, 27 May 2013 08:47:34 +0000</pubDate>
      
      <guid>http://leaver.me/2013/05/27/%E8%AF%91%E5%8F%8D%E5%B0%84reflection%E5%92%8C%E5%8A%A8%E6%80%81dynamic/</guid>
      <description>反射  简单用法实例：  // 浏览方法 foreach (MemberInfo objMemberInfo in parameterType.GetMembers()) {Console.WriteLine(objMemberInfo.Name);}
// 浏览属性. foreach (PropertyInfo objPropertyInfo in parameterType.GetProperties()) {Console.WriteLine(objPropertyInfo.Name);}
//开始调用 parameterType.InvokeMember(&amp;ldquo;Display&amp;rdquo;,BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod | BindingFlags.Instance,null, objMyClass, null);实际一点的用处呢：  动态dynamic  简单用法示例：  实际用处：  两者的区别和联系呢 </description>
    </item>
    
    <item>
      <title>双查询注入</title>
      <link>http://leaver.me/2013/02/22/%E5%8F%8C%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/</link>
      <pubDate>Fri, 22 Feb 2013 20:57:02 +0000</pubDate>
      
      <guid>http://leaver.me/2013/02/22/%E5%8F%8C%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/</guid>
      <description>作者：bystander 论坛：法客论坛 这个东西比较难解释。我就不多解释。尽量通过这篇文章大家能够照猫画虎手注即可。想要深入理解的可以去看看mysql数据库的一些知识
介绍一下双查询注入，有时候我们通过order by 语句获取到了确定的列数，可是当我们使用union select或union select all查询的时候，
却会出现一个错误提示，列数不一致。
而我们使用下面的语句：
执行之后就会显示mysql版本，用户名，服务器名, 以及数据目录…
获取数据库里
许多人会在上面的语句里使用:database()方法来获取数据库，
可是。这个方法只能获取一个数据库。如果你入侵的网站存在多个数据库。上面这个查询就不能用了因此使用下面这个方法更好些。。
不同点在于第二个查询语句在information_schema.schemata里查询 schema_name ，这样就能查到所有的数据库了。 注意语句中的Limit 0,1会显示地一个数据库,改成 Limit 1,1 会显示第二个 Limit 2,1 会显示第三个, Limit 3,1 会显示第四个。。以此类推。 补充个： 在普通的SQL注入中，使用如下的语句
会一次爆出所有的数据库 而使用下面的
只会显示当前站点使用的数据库。
获取表名 回正题，我们继续使用双查询来获取数据库的表:
注意语句中的table_schema=0xHEX 这里的hex用你要查询的数据库进行hex编码后替换即可。 同样的，这里可以要修改LIMIT后面的值来得到第二个第三个第四个表。
获取列名 然后我们来获取列名:
和上一句很像，注意这一句&amp;quot;And table_name=0xHEXEDTABLENAME&amp;rdquo; 还是一样的。后面的部分是要查询的表名的hex值，同时，通过增加后面的LIMIT值来获取更多的列名。下面是大家最感兴趣的地方。。从列里面取值。
获取列值 一些人使用：
也就是他们使用tablename.columnname 有个缺点就是一次只能获取一个列的值，要是该表有个1000多列啥的。。一个个就了。。为了更快一些。后来很多人开始使用这个：
这样一次就能获取多个列的值了，但是还有个bug，因为是直接从mysql的所有表里面找，并且没有指定数据库名，如果mysql有两个数据库有同样的一个表名。那么这样找出来的就不知道到底是哪个了。。就混乱了。。所以。现在我们用这个：
好处一个是可以一次获取多个列的值，同时使用 database.table, 可以明确我们要找的表了。不要忘了增加LIMIT来获取下一条记录啊
错误之处还请指正。</description>
    </item>
    
    <item>
      <title>C#多线程揭秘</title>
      <link>http://leaver.me/2013/02/12/c#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8F%AD%E7%A7%98/</link>
      <pubDate>Tue, 12 Feb 2013 16:31:22 +0000</pubDate>
      
      <guid>http://leaver.me/2013/02/12/c#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8F%AD%E7%A7%98/</guid>
      <description>文章略长。。。 Demo下载：Demo.Threading.zip 介绍 本文将通过一些例子来展示.net 中如何实现多线程，涉及到以下四部分。 1 .线程概念 2 .如何实现多线程 3 .如何确保线程安全 4 .死锁
什么是进程 一个进程就是一个可执行文件运行的操作系统上下文环境。它被用来分隔虚拟地址空间，线程，对象句柄（指向类似文件这样的资源的指针），以及环境变量，进程还有一些类似优先级类和最大内存分配的属性。
也就是说： 1 .一个进程就是一个包含资源的内存块。 2 .操作系统执行的一个单独的任务。 3 .一个正在运行的软件 4 .一个进程拥有一个/多个操作系统线程
一般的。一个进程最大可以是4GB的内存空间，这块内存是安全，私有，其他进程是无法访问的。
什么是线程 一个线程就是在一个进程里执行的一条指令流，所有的线程都在一个进程里执行，也就是一个进程可以包含多个线程。线程公用进程的虚拟地址空间。线程是操作系统的调度单元。一个线程的上下文由操作系统进行保存/恢复。 也就是说： 1 .一个线程是进程里的一条指令流。 2 .所有的线程在进程里。一个进程可以有多个线程 3 .一个进程的所有线程使用进程的虚拟地址空间。
什么是多线程 多线程指的是进程同时有多个线程活动。这可以通过时间片的线程模拟或是多cpu上的超线程来实现。可以提高性能。 多线程-为什么或是为什么不? 为什么多线程 1 .保持UI响应。 2 .提高性能(对于cpu密集型和I/O密集型的进程) 为什么不多线程 1 .过度使用降低性能 2 .代码复杂，增加设计时间，潜在的bug
线程池 线程池为你的程序提供了一个由操作系统管理的机制。在线程池里的都是后台线程。一个线程池线程在程序的前台线程都退出后，也会推出。每个进程一个线程池。默认情况下。每个处理器会为进程分配25个线程。但是可以通过SetMaxThreads 方法来改变。
.net 中的线程 在.net 中，线程可以通过下面6个方法来实现。 1 .Thread线程类 2 .Delegates委托 3 .Background Worker 4 .ThreadPool 线程池 5 .Task任务类 6 .Parallel并行类
下面的几部分里。我将逐一展示实现方法。
简而言之，多线程就是通过使程序同时运行多个任务来最大化计算机能力，同时能够保持UI响应。下图是一个例子的图示。 
代码 提供的源码是一个简单的WinForm程序。模拟了.net中委托，线程类和Background Worker三种方法。 程序异步执行一个繁重的操作，这样UI就不会无响应。三个方法都是模拟的。 
这个“繁重”的操作 真实的开发中，这个繁重的操作从轮询数据库到流媒体操作都可以。基本上可以是任何事情。源码里面是向一个字符串追加值。String是不能变的。追加的时候，新的字符串变量会被创建，旧的会被丢弃，这是由CLR处理的。如果做很多次这个操作，是很耗资源的。这也是为什么我们使用Stringbuilder.Append 来代替这个操作。通过调整界面中的次数。可以通知追加的次数。
后面我们有一个Utility泪，有一个LoadData() 方法。类里面也有一个和LoadData() 有着同样签名的委托
同步调用 当点击Get Data Sync按钮的时候。操作和UI在同一个线程里，因此阻塞了UI线程。因此。UI线程会未响应
异步调用 使用委托（异步编程模型）
如果你选择了“Delegates”单选按钮，那么LoadData()方法就会通过使用委托来异步调用。首先通过utility.LoadData(). 的地址初始化delLoadData 类型，然后调用委托的BeginInvoke()方法。在.net的世界里。任何一个有着BeginXXX和EndXXX名字的方法都是异步的。比如delegate.Invoke()将会在同一个线程里调用方法。而delegate.BeginInvoke()则会另开一个线程调用。 BeginInvoke()有三个参数 1 .传递给Utility.LoadData()方法的参数 2 .回调方法的地址 3 .对象的状态
回调 一旦我们开了一个线程执行一些操作，我们就想知道操作正在发生些什么，换句话说。我们需要当操作完成的时候我们能够收到通知。有三种方法可以知道一个操作是否完成。 1 .回调 2 .轮询 3 .等待直到完成 在我的源码里，我们使用回调方法来捕获线程的完成。回调只需要在调用BeginInvoke的时候把回到函数的名字传递进去。这会告诉线程当你做完工作以后调用这个回调方法就好了。
一旦一个独立线程里的一个方法启动。你也许关心也许不关心方法的返回值，如果一个方法没有返回值，那么可以叫做“触发然后忘记的调用”，这种情况下就不需要回调函数了。这里callback直接传入null就可以了。
在我们的例子中，我们需要一个回调方法，因此，哦们需要传递回调方法的名字到参数里。这里我们的回调方法的名字就叫做CallBack(),纯属巧合。
回调方法的签名都是void MethodName(IAsyncResult asyncResult). IAsyncResult包含了关于线程的一些必要的信息，返回的数据可以像下面这样提取。
而轮询的方法（本例没有使用）则是像这样
等待直到完成，如名所示，就是等待直到完成。
更新UI 既然我们已经捕获了操作结束，并且取回了LoadData()的结果。我们需要用结果来更新UI，但是有个问题。文本框需要在UI线程里更新，结果在回调里取到了。回调和他启动的时候是一个线程(他是由新开的线程启动的)。因为UI线程和回调不是同一个线程。换句话说。文本框不能像下面这样更新。
回调里执行这一行将会导致一个跨线程的系统异常。我们需要在后台线程和Ui线程之前构建一个桥。来更新文本框的值。可以通过使用Invoke()或是BeginInvoke()方法。 我定义了一个方法来更新UI
对上面的方法定义一个委托
如下调用BeginInvoke()方法。
需要注意的是一旦一个线程通过委托启动。它就不能取消，暂停，或是终止，我们无法控制那个线程。
使用Thread线程类 同样的操作可以是哟哦那个Thread类来完成。这个类的优点是你可以对操作有更多的控制，比如暂停/取消操作，类在System.Threading命名空间里。 我们有一个私有的方法LoadData(),他是Utility.LoadData()方法的一个包装。
这样做是因为 Utility.LoadData() 需要一个参数。而我们需要一个ThreadStart委托，这个委托没有参数。
这个委托没有参数，为了防止我们需要传递参数，我们可以使用有参的ThreadStart委托，不幸的是，这个委托只能把object作为参数，而我们需要一个字符串所以需要类型转换。
是的。Thread泪可以对线程有更多的控制。中断。终止，获取线程状态。 使用BackgroundWorker 这个类是一个组件，可以使得线程使用更简单，这个BackgroundWorker类的主要特点就是可以异步的报告进度，这就可以用来更新状态栏，保持UI可视化的更新进度 为了完成操作，我们需要把下面两个属性设置为true，缺省时false •	WorkerReportsProgress •	WorkerSupportsCancel
这个类有三个主要的事件DoCount, ProgressChanged, RunWorkerCompleted 初始化的时候需要注册这三个事件</description>
    </item>
    
    <item>
      <title>recon-ng开源信息探测框架</title>
      <link>http://leaver.me/2013/02/02/recon-ng%E5%BC%80%E6%BA%90%E4%BF%A1%E6%81%AF%E6%8E%A2%E6%B5%8B%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 02 Feb 2013 06:52:28 +0000</pubDate>
      
      <guid>http://leaver.me/2013/02/02/recon-ng%E5%BC%80%E6%BA%90%E4%BF%A1%E6%81%AF%E6%8E%A2%E6%B5%8B%E6%A1%86%E6%9E%B6/</guid>
      <description>作者：bystander 博客：http://leaver.me 微博：http://t.qq.com/lazystander 论坛：法客论坛
首发。转载什么的请注明出处。起码给我留个链接啥的嘛。
首先介绍一下。这个工具是国外刚刚发布的。主要用来渗透前的信息探测。使用类似Metasploit 主要有 Auxiliary： 这个模块查询主机信息泄漏页。进行hash反查，模糊名称精确，检查某个email是否密码泄漏，域名解析ip等 Contacts： 这个模块探测和某一公司有关的人员的信息，主要包括 LinkedIn 和Jigsaw 这两个模块。得到的信息可以被Auxiliary模块使用，如果和Social Engineer Toolkit(社会工程学工具集，这个工具已经发布了。是开源的。大家可以看看)，一起。效果强大。
Hosts： 这个用来获取站点子域名。。包括使用baidu。Google bing等。。效果相当强大。 Output： 这个模块用来创建输出报表 Pwnedlist： 这个模块不是得shell的。他可通过 Pwnedlist.com 提供的api，如果这个网站被入侵过。那么可以直接获得其他黑客泄漏的帐号密码。。（需要去 Pwnedlist.com 注册）
安装方法： bt下直接
然后有可能提示输入密码，好象是随便输一个用来保护版本控制。。我输的是toor。。 然后就安装好了。输入
然后
首先查看有哪些模块。输入
图一

我以获取子域名为例，通过我前面的介绍你已经知道了hosts模块里的所有模块基本都是干这事的。我用里面的baidu模块来说明。你也可以使用bing等，，
输入命令
图二

刚开始你可能不清楚这个模块的说明。那么继续输入info即可查看模块的详细说明 要开始使用。我们输入
和Metasploit很像把。可以查看要使用需要的配置。
图三

看表，会发现有三行。第一行是标题，第二行是域名设置，第三行是输出。这个current value也就是当前值已经为true。所以不用设置。req的意思是是否必须设置。我们输入 baidu.com就是你的目标了。
就会从百度的结果里提取百度的子域名信息了。要开始。我们输入
图四

更多希望大家发掘吧。我抛砖。求引玉。</description>
    </item>
    
    <item>
      <title>Lambda高手之路第六部分</title>
      <link>http://leaver.me/2012/12/28/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86/</link>
      <pubDate>Fri, 28 Dec 2012 14:24:35 +0000</pubDate>
      
      <guid>http://leaver.me/2012/12/28/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86/</guid>
      <description>今天武汉地铁通车了，今天介绍一些新的Lambda设计模式，应该是最后一部分了。
本节介绍一些核心有lambda表达式的模式，我不认为他们完全是新的模式，但是至少我还没有看到有人给他们起过名字，我于是决定尝试取个可能好，也可能不好的名字，这样我起码能很容易的给别人描述，有话在先，许多模式相当强大，但是可能会引入潜在的bug，所以小心为上
复杂的多态
Lambda表达式也可以被用来创建一些多态（override），而不用使用abstract或者virtual关键字（当然这并不意味着就不能用），考虑如下的代码片段
看起来没什么新的知识，我们创建一个类，里面有一个属性（一个lambda表达式），又一次JavaScript化了，有趣的地方是：属性暴露的这个部分不只是本类可以改变，子类也可以改变，看代码
看到了。我们可以改变这个方法。或者进行更精确的操作，这种方法的缺点是我们不能直接访问父类的实现，也就缺乏了基类的能力，因为，这个父类的属性会有同样的值，如果程序员真的需要这样写，我建议你遵循 pattern
这样的话，子类就不得不拥有了 AddSomeAction() 方法，而这个方法是吧当前的方法压入堆栈，那样我们可以恢复之前的状态。
这种模式我起了一个名字叫做Lambda属性多态模式（LP3），它简单的描述了可以在属性里捕获任何方法。之后可以被子类所设置，栈是这个模式的一个附加品，没有改变我们使用属性来完成的模式目标
为什么要用这种模式？有几个理由。地一个，因为我们可以用。但是等一等。如果你使用当中不同的属性，这个模式会变得相当棘手，突然，多态变成了一个完全的新方法。但是这也许是一个不同的模式，现在我想说这个模式完成了以前人们认为不可能的事情
举个例子，你想要（不建议，但是也许对该问题是最优雅的解决方法了。）重写一个静态方法，好吧。静态不可能被继承，原因很简单，师承是对实例对象来说的。而静态方法不属于任何一个实例，对于所有的实例都是一样的。这会引发一个警告，下面的例子也许并不如你所想的结果，因此，除非你非常清楚。否则不要乱用。 看代码
这很简单，希望没有对你产生误导，这种模式有时候会让事情变得异常复杂，这也是为什么我总是避免使用它。不过他很有用。（可以通过该方法构造所有的静态属性和方法，并且可以使你总是获得你感兴趣的那个）只要你不感到头疼，这是解决静态多态性的一个好方法。是的。静态多态性是可能的。
简单请求一个方法
之前我已经介绍过这个方法了。但是我没有说名字，这就是方法字典模式，这个模式的一个基础就是一个哈希表或是一个字典，包含一个keys（通常是字符串，但取决于具体的情况），这些keys对应一些特定的方法，这个模式也指定了一个特殊的方法构造这些字典，否则，一个简单的switch-case就搞定了，看代码
这哪里需要字典？好像不需要。事实上我们写的更好一些。
等等，这个模式现在没有优点了。。事实上，这个模式并不特别好写，她还需要多写写代码，但是我们可以使用反射来自动化这个字典的构造，这样我们就会和switch-case一样搞笑了。但是我们的代码更加健壮，并且维护更简单，如果你写switch-case。。你就需要手工添加很多分支语句了。。
我们看一种可能的实现方法。我通常更倾向于添加一些类型转换，这样就可以方便的使用keys对应的值了。当然，你也可以通过其他方法实现，比如使用一致的方法签名，这里我还是用转换。
现在看起来好多了，事实上。这个模式节省了我很多时间。这个模式最好的就是：它使你可以写出优雅的插件。通过不同的库扩充功能。为什么。你可以使用该方法来扫描未知的库，这些库符合一些确定的模式。然后包含他们进入你的代码，这样。没有任何问题。其他库的方法就会继承成你的代码里。你所需要做的仅仅如下：
现在，我们所需要做的就是确定加载的插件，并且添加一些方法来处理这些事事情。最后。可以通过调用LoadPlugin()方法从给定的程序集实例上加载方法。这只是这个模式的一个应用。而我其实还可以做很多。。。比如我们也在JavaScript里面使用。那里可是没有内置的反射的。。</description>
    </item>
    
    <item>
      <title>Lambda高手之路第五部分</title>
      <link>http://leaver.me/2012/12/27/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86/</link>
      <pubDate>Thu, 27 Dec 2012 09:15:29 +0000</pubDate>
      
      <guid>http://leaver.me/2012/12/27/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86/</guid>
      <description>武汉下雪了。。今天介绍Lambda表达式非常有用的情况。。ps:这个高手之路已经翻译了10000多字了。。疼啊。。
一些模式比另一些模式有时候更加合适，真正有用的模式是自定义方法表达式，用爱促使话一些对象的部分，我们考虑下面这种情况。
我们想要创建一个可以处理多种延迟加载的对象，这意味着即时对象已经被实例化了，我们还没有加载所有请求的资源，一个理由就是防止大量的IO操作。（比如通过网络传输），当我们开始使用数据的时候，我们想要确定数据足够新鲜，现在有一些确定的方法可以做这个。并且最有效的显然是实体框架已经用LINQ解决了延迟加载的问题，Iqueryable仅存储了查询，而没有任何无关的数据。一旦我们请求一个结果。不仅仅构造的查询被执行，同时也被以更高效的方式执行，比如一个在远程数据服务器上的SQL查询。
在这里，我们仅仅想要看看两种情况的不同点，首先，我们查询，一切就绪，查询应该在已经加载了的数据上进行。
简单来看，这里我们有两种不他哦你的方法，地一个是我们把数据从数据库里提取出来（也就是Database静态类所做的），然后第二个方法将会过滤从数据库里提取出来的数据。一旦我们将会从我们的第一次查询取得结果，当然我们也可以构造内置的其他方法来重置类的行为，对于工业级的代码，其他的方法也许更加有用。
另一个例子是初始时间分支，假设我们有一个对象，该对象有个方法叫做Perform(),这个方法可以用来调用一些代码，包含这个方法的对象可以被初始化，初始化有三种方式。
 通过传递方法来调用 通过传递一些包含这个方法的对象来调用 或者通过传递第一种情况下的序列化以后的信息来调用。  现在我们可以保留所有的三种方式做全局变量。而Perform方法将不得不查看当前的状态（或者是保存在枚举变量里，或者和null进行比较）然后检测被调用的正确的方式，最后调用开始。
更好的一种方法是吧Perform()方法写成一个属性，这个属性仅仅允许在类里面进行set，它是一个委托类型，现在我们可以在对应的构造方法里面直接设置这个属性，因此，我们可以不用全局变量，也不用担心这个对象是如何实例化的，这种方法更好。
看一小段简单的代码。
即时这个例子看起来如我们所愿被构造了。让阿尔。大多数情况下只使用前两种，但是随着领域特性语言，编译器，日志框架，数据访问层和其他很多情况下，通常有很多方式可以完成，但Lambda表达式也许是最优雅的。
考虑这种情况，我们可以在函数编程领域体会到即时调用方法表达式的好处，我们可以看到C#中IIFE的一种用法。用的不多。但是我认为真的很好。但不是用在这种情况下。
我们也可以使用即时调用方法来防止一些确定的非静态的方法被重复调用。这就会出现自定义方法和初始时间分支和IIFE的组合使用了。
下一节介绍一些新的Lambda设计模式</description>
    </item>
    
    <item>
      <title>Lambda高手之路第四部分</title>
      <link>http://leaver.me/2012/12/24/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</link>
      <pubDate>Mon, 24 Dec 2012 19:20:12 +0000</pubDate>
      
      <guid>http://leaver.me/2012/12/24/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</guid>
      <description>首先祝大家平安夜快乐。本篇介绍一些流行的JavaScript模式。为下一篇打基础
使用/了解JavaScript的一个好处就是函数的高级用法。。在JavaScript里。函数仅仅是对象。他们可以有赋给他们的属性。而在C#中。我们不能做我们可以在JavaScript的全部事情。但是我们仍然可以做些事情。一个原因是JavaScript在函数里给变量以作用域。因此，不得不通过创建函数，大多数情况是匿名的来定位变量。而在C#中。通过使用块，通过花括号来创建作用域
当然，换种方式来说。C#中，函数也会给变量作用域。通过使用Lambda表达式。我们通过花括号在其里面创建了一个变量。然而。我们也可以局部的创建作用域。
我们来看看通过使用Lambda表达式可以实现一些在JavaScript里面有用的模式把。
回调模式
这个模式是个老的模式。事实上。回调模式从.net 的第一版就开始使用了。但是是以一种很简单的方式实现的。而现在。通过使用Lambda表达式。闭包，捕获变量等特性能够允许我们写出如下的代码来。
对于JavaScript程序员会觉得这没什么啊。他们使用这个模式太多了。然而，它非常有用。因为我们可以使用参数作为Ajax相关事件的事件处理器（比如oncompleted，onsuccess），等等。如果你使用LINQ，那么你可能也会用到回调模式的一些东西。举个例子。LINQ的where子句将会在每一次迭代中回调你的查询语句。这只是回调函数的一个例子。在.net的世界里。事件如它名字所暗示的那样。通常是事件处理的首选方法。这有时候很像一个回调。他有两个参数。有一个特殊的关键字和一个类型模式（两个参数分别是sender和arguments，sender通常是object类型。Arguments通常继承自EventArgs） 可以通过+= 和-=给事件添加/删除事件处理程序。
返回方法 和普通的方法比较。Lambda表达式也可以返回一个方法指针（就是一个委托实例），这意味着我们可以使用Lambda表达式创建/返回一个lambda表达式（或者今年仅是一个已定义好的方法的委托实例），大量的情况下。这个模式也很有用。首先看一下例子。
代码本应该更短些。我们可以让default如果请求的语言没有找到。只是抛出一个异常即可。不过。这个例子展示了这是一种方法工厂。另一种同等效果的方法是包含一个Hashtable。或者更好的话用Dictionary&amp;lt;K, V&amp;gt;
即使这看起来似乎有点过度工程化了。但是也许这是方法工厂最好的例子了。毕竟方法简单易扩展，可以被用在很多情况下。这中模式和反射的组合可以是的程序代码更松耦合，更易使用。并且代码更健壮。下图展示了模式的工作流程 
自定义方法 自定义方法模式一个JavaScript中普遍的技术。可以用在代码中提高性能和健壮性，这种模式的背后思想是方法被设置为一个属性。于是可以和其他方法非常方便的交换。我们看一下具体的代码
这段代码做了什么？好吧。第一种情况下，我们得到第一个素数。也就是2.虽然这很显而易见。我们可以体征我们的算法默认来排除掉所有的偶数。这就加速我们的算法。但是我们依然能够得到开始的偶素数2.我们就可以通过调用NextPrime方法来获得素数了。我们就可以在第二部分里有话我们的算了。
我们已经看到这种写法可以优化性能。我们可能一下这个例子
这里我们有了两根分开的区域。一个是为钱1000个数准备的。其他的则留在了另一个区域。通常我们可能需要区分这两种情况。这就是我们为什么使用了自定义方法，当小区域执行完后，自定义函数就会改变了。来执行大的区域了。
即时执行方法表达式
在JavaScript中即时执行方法表达式也叫做IIFEs,也相当普遍。这是因为在JavaScript中，不像C#中的花括号可以构造一个局部变量。因此一个变狼可能会污染一个全局对象。（最有可能就是一个window对象），由于很多原因，这种情况很不好。。
解决方法也很简单，当花括号不能给一个作用域的时候，方法却可以。因此，定义在方法里面的变量就被限制在这个方法里。就像是他的孩子一样。因此，通常JavaScript用户想让那些方法立刻执行。否则，是对变量名和语句行的浪费。另一个原因就是这个方法只执行一次。
在C#中我们也可以写出类似的方法。我们也会得到一个新的作用域。但这不是我们主要关心的。因为我们可以随心所欲创建新的作用域，我们看些例子
这段代码很容易理解。然后，如果我们想要传一些参数时候。我们需要定义他们的类型你个，我们看一下如何给即时执行方法传递参数
看上去似乎没做什么。然而。我们可以和async关键字组合起来。我们看
Ok了。
即时对象初始化
我把这个模式放在关于Lambda表达式的文章里是因为匿名对象比我们刚刚的一些简单的例子能表达的要多得多。其中一个就是匿名对象也可以包含Lambda表达式。这可以作为我写在本文里的理由。
如果你想要运行这个模式，你可能会看到一个异常。。至少我看到了。。这难以理解的理由是Lambda表达式不能被赋给匿名对象。如果你也没明白。。那我们看来是坐在一条船上的。 幸运的是，编译器已经告诉我们了。“哥们，我不知道我该为你的那个Lambda表达式创建哪种类型的委托啊”我们可以帮一下编译器。如下所示。
一个问题就产生了。方法（这里是Ask）存活的作用域是什么？答案是他存活在创建匿名对象的类里面，或者如果他使用了捕获变量，就在他自己的作用域里面。因此，编译器仍然创建了一个匿名对象（包含对编译器生成的类的元数据，实例化了一个有着类信息的新的对象），但是只是设置了委托对象Ask属性
注意：你应该避免使用这个模式，当你真的想要访问一个匿名对象的所有属性的时候。理由如下：C#编译器请求在你使用每一个对象之前，应该首先声明他。因此，用的地方一定在声明之后，但是编译器怎么知道？在编译器看来。Person变量还没声明完呢。就开始使用了。 所以，在上面那个Lambda表达式里并不能直接访问person的Name和Age属性 有一个方法跳出这个陷阱（事实上有很多种，但我只喜欢这一种最优雅的，考虑下面这段代码
现在因为我们之前已经声明了，我们也可以说明person为object对象。但是这样的话我们就要用到反射机制了（可能还需要一些漂亮的包装器），来访问匿名对象的属性，在这种情况下，我们依赖于DLR，他会对这种情况出现一个最漂亮的包装器，现在这段代码就非常JavaScript化了，我也不知道是好还是坏，这也就是为什么我说这个是一个注意点。。
初始时间分支
这个模式事实上和自定义方法非常接近，唯一的不同，这种情况下，该方法并不定义自己，而是包含其他方法。显然是可能的。如果这个“其他方法”不是通过传统的方式定义，而是通过属性，（成员变量）
这种模式的别名也叫做加载时分支，是一个优化模式，这个模式用来避免switch-case或if-else语句等控制结构的大量使用。也可以理解为这个模式为代码永久性的创建了确定分支之间的连接。 考虑下面这个例子
我们都做了什么呢？首先我们有一个方法读取用户配置（由一个配置Setting类来保存），如果我们发现启用了自动设置。我们就给AutoSave这个属性赋上全部的代码，否则我们就放一个空方法在这里，而们就可以通过调用AutoSave（）一次就行了，不再需要检查配置设置或其他的什么情况了。我们也不需要保存一个特殊的布尔变量，因为对应的方法已经被动态的设置了。
有人也许认为这不是一个巨大的性能提高，但是这仅仅是一个小例子，在一些复杂的代码里，这会节省很多时间，尤其是代码越来越复杂的情况下。
另外（我认为这是最主要的原因），代码更加容易维护（如果你了解这个模式的话）没有了不必要的控制逻辑，程序员可以更加专注于重要的东西—调用这个自动保存的具体操作
在JavaScript中，像初始时间分支模式被用在很多性能检测上（比如浏览器检测）不去管浏览器检测实际上是很邪恶的，并且不应该在任何网页上检测用户的浏览器， 性能检测非常有用，通常和这种模式一起组合使用，这也是Jquery用来对Ajax请求检测需要的正确对象的方法。
下一部分介绍Lambda表达式超级有用的情况，同样圣诞节快乐。</description>
    </item>
    
    <item>
      <title>Lambda高手之路第三部分</title>
      <link>http://leaver.me/2012/12/20/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</link>
      <pubDate>Thu, 20 Dec 2012 20:12:54 +0000</pubDate>
      
      <guid>http://leaver.me/2012/12/20/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</guid>
      <description>背后的秘密-MSIL
通过著名的LINQPad，我们可以更深入的查看MSIL代码而没有任何秘密。下图是一个LINQPad的使用截图 
我们会看三个例子，第一个Lambda表达式如下：
对应的普通函数是这样的
生成的MSIL代码片段如下：
最大的不同是方法的名称用法不同。而不是声明。事实上。声明是完全一样的。编译器在类里面创建了一个新的方法来实现这个方法。这没什么新东西，仅仅是为了我们使用Lambda表达式方便代码编写。从MSIL代码中，我们做了同样的事情。在当前对象里调用了一个方法。
我们在下图里演示一下编译器所做的修改。在这个图例。我们可以看到编译器把Lambda表达式移动成了一个固定的方法。
 第二个例子将展示Lambda表达式真正的奇妙之处，在这个例子里。我们既使用了有着全局变量的普通方法也使用了有捕获变量的Lambda表达式。代码如下
没什么不同的似乎。关键是：lambda表达式如何被编译器处理
和第一个例子一样。机制相同。编译器把lambda表达式移动到一个方法里。但是不同的是，编译器这次还生成了一个类。编译器为我们的lambda表达式生成的方法会放在类里，这就给了捕获的变量一个全局的作用域，通过这样。Lambda表达式可以访问局部变量。因为在MSIL里。它是类实例里面的一个全局变量。
所有的变量因此就可以在新生成的类的对象里赋值/读取了。这解决了变量之间的引用问题。（其实就是只保留了对该类实例的引用。）编译器也足够智能之会把这些捕获的变量放到类里面。因此，当我们使用Lambda的时候才没有太大的性能问题。无论如何。注意。由于保持了对lambda表达式的引用，因此可能造成内存泄漏。只要方法还在。变量就仍然存活。显而易见。而现在我们知道了原因。
我们再次用图示来说明。这这种闭包情况下里。不仅仅方法会被移动。捕获的变量也会被移动。所有被移动了的对象会被放到一个新生成的类里。因此一个没有名称的类就隐式的出现了。 
下一节将是映射流行的JavaScrpit模式。</description>
    </item>
    
    <item>
      <title>Lambda高手之路第二部分</title>
      <link>http://leaver.me/2012/12/19/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 19 Dec 2012 20:03:20 +0000</pubDate>
      
      <guid>http://leaver.me/2012/12/19/lambda%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid>
      <description>闭包的影响 为了展示闭包的影响，我们看下面这个例子。
这个问题很怪，我在我的JavaScript课程上经常问我的学生。95%的学生会说。显然按钮0显示0，按钮1显示1，等等。而不足5%的学生学习了闭包之后会明白。所有的按钮都会显示10.
局部变量i的值改变了。并且等于buttons.Length。也就是10了。想要避免这个诡异的情况也很简单。如下就行了。
问题解决了，但是index变量是一个值类型，因此保留了“全局”i的一个拷贝
最后一个话题是一个叫做表达式树的东西，他和Lambda表达式协作。并且，他会使得在ASP.NET MVC中的Html扩展方法发生一些很奇妙的东西。关键的问题是：如何发现目标函数
1. 传递进去的变量的名称是什么 2. 方法的主体是什么 3. 函数体里使用了什么类型
Expression 解决了这些问题，他允许我们挖掘生成的表达式树，我们也可以执行传递给Func和Action委托的函数，而且，可以在运行时解析Lambda表达式
我们看一下如何使用Expression 类型的例子
这是Expression最简单的用法了。规则也相当直接。通过构建一个Expression类型的对象。编译器为生成的解释树生成一些元数据。这个解释树包含所有相关的信息，比如参数和方法体。
方法体包含完整的解释树，我们可以访问这些操作。就像完整的语句一样。也可以操作返回指和类型。当然，返回可以为null，无论如此。大多数情况下。我们对表达式很感兴趣。这和ASP.NET MVC中处理Expression类型的方法是很相似的—可以得到使用的参数的名字，而好处是显而易见的。不会出现名称拼写错误了。也就不会出现因此而出现的编译错误了。
注意：当程序员仅仅对调用的属性的名字感兴趣的时候。有一个更简单，更优雅的解决方案，那就是参数特性CallerMemberName 这个特性可以得到调用方法/属性的名称。而字段被编译器自动填充。因此，如果我们仅仅想知道名字，而不想知道其他更多的信息，那么我我们只需要写出像下面这个例子里的代码就行了。通过调用WhatsMyName() 方法可以返回方法的名字
Lambda表达式的性能 有一个很大的问题：Lambda表达式有多快？好吧。首先，我们期望他们能和我们一般的函数一样快。下一节里。我们会看到Lambda的MSIL代码和普通的函数没有太大的不同。
最有趣的一个讨论是如果Lambda表达式产生了闭包，将会和使用全局变量的方法一样快。这就产生了一个有趣的问题，和一个区域内局部变量的数目多少会有关系吗？
我们看看测试代码，通过4个不同的指标，我们可以看到普通方法和Lambda方法的不同。
本来用Lambda表达式我们可以把代码写的更好。最终我没有这样做。是为了防止影响看最后的结果。因此，本质上。上述代码里有三个方法 1个是Lambda测试，一个是普通测试，还有一个是在普通测试里调用的方法。而没有的第四个方法其实是我们的lambda表达式。在第一个方法里已经创建了。计算过程很简单，我们随机取数字防止编译器做任何优化。最后我们对普通方法和Lambda方法的不同很有兴趣。
如果我们运行这个测试程序。我们会发现Lambda表达式并不总是比普通方法差。我们惊奇的是有时候甚至Lambda表达式更快一些。然而，在有闭包的情况下，，就不对了。这就是说大多数情况下我们可以毫不犹豫的使用lambda表达式。当使用闭包的时候会出现一点点的性能损失，不过还好，下一节会讲述性能损失的几个原因。 下面是测试输出的结果表
Test Lambda [ms] Normal [ms] 0 45+-1 46+-1 1 44+-1 46+-2 2 49+-3 45+-2 3 48+-2 45+-2
下图是上表的结果，我们可以看得到普通的方法和Lambda表达式基本上限差不多。当使用Lambda表达式的时候没有太大的性能损失。

第三部分会介绍背后的秘密-MSIL</description>
    </item>
    
    <item>
      <title>3分钟理解Lambda表达式</title>
      <link>http://leaver.me/2012/12/08/3%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 08 Dec 2012 19:26:51 +0000</pubDate>
      
      <guid>http://leaver.me/2012/12/08/3%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1.什么是Lambda表达式
Lambda表达式是一个匿名方法，通常在LINQ中被用来创建委托
简单来说。它是一个没有声明，没有访问修饰符，没有返回值。甚至没有名字的方法。
 2.为什么我们需要使用Lambda表达式？或者说为什么我们要写一个没有名字的函数？
为了方便，这种快捷方式允许你在调用的地方直接编写代码，尤其是你想调用的代码只会在这个地方使用一次。并且方法体本身很短。节省了单独写方法中写声明等等的麻烦。。
好处
1.代码量减少。不必写方法的名称。返回值和访问修饰符
2.当阅读代码的时候。直接就可以看到被调用函数的代码，不用去别的地方。
Lambda表示应该短些。太复杂了。可读性就下降了
 如果编写Lambda表达式
Lambda基本的定义是：参数=&amp;gt;执行代码
举个例子
n是输入参数 n % 2 == 1 是函数体
你可以读作：给这个匿名方法传入一个参数n，如果n是奇数就返回true
 使用该Lambda的例子
ok.基本的Lambda表达式就是这样了。</description>
    </item>
    
    <item>
      <title>获取操作系统版本信息</title>
      <link>http://leaver.me/2012/11/23/%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Fri, 23 Nov 2012 13:24:50 +0000</pubDate>
      
      <guid>http://leaver.me/2012/11/23/%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/</guid>
      <description>坊间流传的代码都有些问题，比如不能正常获取win7以上的版本信息，不能获取诸如专业版，旗舰版等的信息，不能正常获取操作系统位的信息。
使用代码，写了一个简单的库来实现效果。用法大概如下：
对比一下坊间的几种不足： 总的来说。最大的问题就是不能正确检测你的操作系统到底是32位还是64位。几种方法大致如下： 1. 使用IntPtr指针的大小 最关键的一句代码是：
但是事实上，这个返回的不是操作系统的位数，返回的是运行的程序的位数，如果在64位的windows上以32位的模式运行了这个程序，那么就会返回32.
2. 使用PROCESSOR_ARCHITECTURE 环境变量
这就是纯粹的误导了，因为和1的情况一样。不能返回处理器的位数而是返回了运行程序的位数，如果在64位的windows上以32位的模式运行了这个程序，那么就会返回32.
3. 使用PInvoke 和 GetSystemInfo 注意：为了保持文章不要太长。。我没有包括PInvoke API的声明，（译者注：C#的互操作性嘛），但你可能在我提供的源代码里找到。
老问题，还是会返回运行程序的位数，而不是操作系统/处理器的位数。 4. 使用PInvoke和GetNativeSystemInfo 我看到过有人说上面的都不可信。可以使用GetNativeSystemInfo代替，代码和上面一样，只是把GetSystemInfo换成GetNativeSystemInfo就好。
结果不一样了。但是。。。这个API返回了处理器本身的位数，而我对操作系统的位数感兴趣。。毕竟64位的处理器上也可以轻松运行32位的操作系统 5. 组合 IntPtr.Size 和 IsWow64Process
如果IntPtr是64.操作系统必然也是64位，因为你不能在32位的操作系统上运行64位的程序 如果程序在32位模式下运行，代码会检测是否是64位的处理器，而程序在32位模式下运行来判断是32位还是64位。 如果返回的是64，那么操作系统是64位，但是程序以32位的模式运行，如果是32，那么操作系统也是32.
最后，我在lib里还加入了一些方法。以便区分程序/操作系统/处理器的位数。
源码下载：
[downloadicon href=http://pan.baidu.com/share/link?shareid=161028&amp;amp;uk=1493685990]OSVersion.zip[/downloadicon] 译自：http://www.codeproject.com/Articles/73000/Getting-Operating-System-Version-Info-Even-for-Win，有删减。</description>
    </item>
    
    <item>
      <title>C#中的throw</title>
      <link>http://leaver.me/2012/11/18/c#%E4%B8%AD%E7%9A%84throw/</link>
      <pubDate>Sun, 18 Nov 2012 12:33:49 +0000</pubDate>
      
      <guid>http://leaver.me/2012/11/18/c#%E4%B8%AD%E7%9A%84throw/</guid>
      <description>Throw会抛出/传递异常,通过在catch块里使用throw语句.可以改变产生的异常,比如我们可以抛出一个新的异常,throw语句有各种各样的,并且很有必要.
例子 我们首先看一下三个方法,分别叫做A,B,C，他们使用不同的throw语句。方法A使用了无参的throw语句。这可以被看作是rethrow(继续抛出)—他会抛出已经出现的同样的异常
继续，方法B throw一个命名的异常变量。这就不是一个完全的rethrow了—因为他虽然抛出了同样的异常。但是改变了StackTrace（堆栈轨迹），如果有必要的话，我们可以收集一些异常信息，而方法C则创建了一个新的异常。 提示:你可以通过这种方法实现自定义的的错误处理 使用throw语句的例子
程序可能的输出结果
Rethrow
接着我们看更多的关于rethrows的细节。Rethrow必须是一个无参的throw语句。如果使用throw ex，那么TargetSie(TargetSite 从堆栈跟踪中获取抛出该异常的方法。如果堆栈跟踪为空引用，TargetSite 也返回空引用。-译者注)和StackTrace都被改变了。
在下面的程序里，X()方法使用了rethrow语句。Y()使用了throw ex语句。我们可以看看当rethrow语句使用的使用，引发异常的方法，也就是异常的TargetSite是在StringToNumber&amp;mdash;一个int.Parse内部的方法。
但是：当throw ex用的时候。就像在Y()里面，这个异常的TargetSite被修改到了当前的Y()方法里。 测试rethrow的例子
输出
总结： 异常处理机制提供了可选的控制路径，它将异常逻辑和异常处理分割开来。并且可以通过throw来rethrow异常或是生成一个新的异常。 译自：http://www.dotnetperls.com/throw
本文由Bystander翻译，转载请注明http://leaver.me</description>
    </item>
    
    <item>
      <title>理解并实现模板模式</title>
      <link>http://leaver.me/2012/10/25/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 25 Oct 2012 22:04:15 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/25/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍 本文实现模板模式
背景 有时候我们需要做很多任务，而做这些任务的算法可能不同，这样可以设计成策略模式，这样。执行该任务的基本的一些代码就是一样的。但程序可可以动态的切换来执行任务的不同部分了。
现在，真实的情况是有些算法，从实现层面山看，有可能有一些步骤是不一样的，这种情况下。我们可以使用继承来完成。
当有个算法，而这个算法的一部分却多样的时候。使用模板模式就很好。GoF定义模板模式为：
 &amp;ldquo;Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm&#39;s structure.&amp;quot;.
 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
 在上面的类图中： AbstractClass：包含两种方法。第一种就是算法的每一步。另一种就是模板方法。模板方法就是那些可以被用在所有独立方法中。并且提供了算法执行的一个骨架 ConcreteClass：这个类重写了抽象类中每一步的方法，包含对这些步骤的个性化实现。
使用代码 看一个简单的例子。假想我们有一个类用来读取数据。并且能够为信息管理系统到处数据。
ReadData和FormatData 的实现不会变。唯一可变的部分就是ExportData方法。该方法对于不同的导出类型不同。如果我们要导出excel文件。我们要实现一个ConcreteClass的实现。
同样如果要导出PDF文件。重写这部分即可
好处就是客户端可以使用DataExporter类，而具体的实现是在派生类中的
 运行时。对算法的调用将会执行真正请求的派生类的方法。 看一下我们的类图 
亮点何在 本文讨论了什么时候模板模式很有用。也简单的实现了。模板模式是一个典型的好莱坞原则： 别给我们打电话,我们会联系你的” 不论什么时候。模板方法总是在调用派生类中的方法。 [downloadicon href=http://pan.baidu.com/share/link?shareid=98214&amp;amp;uk=1493685990]TemplateMethodDemo.zip[/downloadicon]
原文地址：Understanding-and-Implementing-Template-Method-Des 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>理解并实现外观设计模式</title>
      <link>http://leaver.me/2012/10/23/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 23 Oct 2012 18:31:47 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/23/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%96%E8%A7%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍 本文介绍外观模式,并给出简单的实现示例
背景
写软件的时候,有时候需要处理一系列的对象来完成一个确定的任务.比如,我们给一个万能遥控器写代码,我们需要关掉所有的设备,那么,我们有这样几种选择.第一个就是手动选择每一个设备,然后一个接一个的关闭,这好傻.那我们为什么不再遥控器上放一个按钮,我们按一下就关掉了.按钮的命令会与设备控制器通信然后关掉他们.
如果我们又想在晚上12的时候自动关闭设备,那么我们就会有一个基于事件的计时器,与设备通信,然后关闭设备,问题是在两种情况下我们都需要与这些对象通信的函数.
有很多方法解决这个问题,为什么不能有一个对象,该对象的责任就是关闭设备,当我要关闭设备的时候,我调用该对象就行了.这也是外观模式的理念Gof大神定义外观模式 &amp;ldquo;Provide a unified interface to a set of interfaces in a subsystem. Façade defines a higher-level interface that makes the subsystem easier to use.&amp;rdquo;
为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
看看模式图 
注意外观对象仅仅是提供了对函数一起操作,.不能替换子系统的接口.子系统的类仍然可以被系统的其他部分访问.外观为子系统提供了一致的界面.
使用代码 为了模拟外观模式,我们模拟一个小例子.试着实现一个简单的外观对象,该外观对象操作一些WP手机的控制器对象,我们先定义问题
每天早上我跑步的时候,我都得对我的手机做出以下的事情.. 1. 关闭wifi 2. 切换到移动网络 3. 打开GPS 4. 打开音乐 5. 开始跑步追踪器
跑完以后.,我又蛋疼的做出以下几件事 1. 在twitter和facebook上分享我的跑步数据 2. 关闭跑步追踪器 3. 关闭音乐 4. 关闭GPS 5. 关闭移动数据 6. 打开wifi
目前我都是手工做的.,我们来实现这些假想的控制器类吧.
其他的像MobileDataController, MusicController, WifiController 代码都是基本的一样的.
然后模拟一下跑步追踪器这个app
下面模拟一下我的手工过程
手工部分模拟完了.运行效果看看 
好了.我们还是写个外观软件自动做这个吧 该软件对外提供两个接口StartJogging.和 StopJogging 帮我做这些事,(ps:这部分代码中的英文我就不翻译了，和前面的一样)
然后用户这样用
结果如图 
总结之前，看看我们这个例子的结构图 
注意，这只是一个例子，和真实情况有差距。理解就好了
亮点何在
本文讨论了外观模式，很容易和适配器模式混淆，事实上，适配器模式也给用户提供了一个接口，之前的接口就不可访问了。而外观模式的之前的接口还是可以访问的。希望对你有帮助。 Demo下载 [downloadicon href=http://pan.baidu.com/share/link?shareid=90318&amp;amp;uk=1493685990]FacadeDemo.zip[/downloadicon]
原文地址：UnderstandingplusandplusImplementingplusFacadeplus
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>理解并实现装饰器模式</title>
      <link>http://leaver.me/2012/10/22/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 22 Oct 2012 11:31:47 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/22/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>背景 本文讨论装饰器模式,这个模式是因为很多情况下需要动态的给对象添加功能.比如我们创建了一个Stream类.后来需要对这个数据流类动态的添加一个加密功能.有人可能说把加密方法写到流类里面啊.然后使用一个bool变量来控制开关就行了.但是这样.这个加密方法只能写一种..如果用派生类来实现.那么..对于不同的加密方法.,都要创建一个子类,举个例子.比如有时候是一些函数的组合.我们最终的派生类的数目基本上就和排列组合的数目一样了.
我们使用装饰器模式来解决这个问题.GoF描述为 &amp;ldquo;Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.&amp;rdquo;
首先看一下图.理解一下这个模式中每一个类的作用
 •	Component:定义了可以动态添加功能的具体类ConcreteComponents的接口. •	ConcreteComponent: 可以动态添加功能的具体类 •	Decorator: 定义了动态添加到ConcreteComponent类中的功能的接口 •	ConcreteDecorator: 可以添加到 ConcreteComponent.中的具体功能类.
使用代码
我们开一个面包店的例子.面包店卖蛋糕和甜点.客户可以买蛋糕和甜点,同时添加一些额外的东西.额外的东西包括奶油(Cream),樱桃(Cherry),香料(Scent)和会员(Name Card)
如果我们用派生类来实现..那么我们会有如下的类 •	CakeOnly •	CakeWithCreamAndCherry •	CakeWithCreamAndCherryAndScent •	CakeWithCreamAndCherryAndScentAndNameCard •	CakeWithCherryOnly •	PastryOnly •	PastryWithCreamAndCherry •	PastryWithCreamAndCherryAndScent •	PastryWithCreamAndCherryAndScentAndNameCard •	PastryWithCherryOnly •	等等等等
这简直就是噩梦..我们用装饰器模式来实现把. 首先定义Component 接口
前面说过了.这个类定义了能够动态添加功能的具体类(ConcreteComponents)的接口,好吧.然后来创建具体类ConcreteComponents
现在基对象准备好了.看看那些可以被动态添加的功能.我们看看Decorator 类
注意两个地方.第一个就是类实现BakeryComponent 接口,原因是装饰后的蛋糕还是蛋糕,另一个是该类也持有一个BakeryComponent 对象,原因是,我们需要Cake和装饰的项目是is-a关系,但是事实上不是.通过加一个对象就可以模拟is-a关系.
一句话.我们使用继承实现了静态的is-a关系,而是用构成则是一个动态的is-a关系.
然后看看ConcreteDecorators 如何实现
然后看一下如何给一个会员卡添加一个打折的信息.
现在我们的客户端可使用Decorator 来装饰ConcreteComponents 生成不同的组合.看看例子
运行效果
 看看我们的装饰器模式例子的类图结构

亮点在那里 装饰器模式是很典型的开放-封闭原则的例子.我们的类对扩展开放,而对修改封闭. Demo下载 [downloadicon href=http://pan.baidu.com/share/link?shareid=88379&amp;amp;uk=1493685990]DecoratorSampleApp.zip[/downloadicon]
原文地址：UnderstandingplusandplusImplementingplusDecoratorp 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>理解并实现原型模式-实现ICloneable接口.理解深浅拷贝</title>
      <link>http://leaver.me/2012/10/19/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E7%8E%B0icloneable%E6%8E%A5%E5%8F%A3.%E7%90%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Fri, 19 Oct 2012 09:27:21 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/19/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E7%8E%B0icloneable%E6%8E%A5%E5%8F%A3.%E7%90%86%E8%A7%A3%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>本文用C#实现原型模式,也会讨论深浅拷贝,已经如何在.net中高效实现ICloneable 接口 介绍 有时候我们需要从上下文得到一个对象的拷贝，然后通过一些独立的操作来处理他。原型模式在这种情况下很适用
GoF 定义原型模式为用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype.&amp;rdquo;
看一下类图

主要的参与者有 • Prototype: 抽象类或接口，定义了方法来拷贝自己 • ConcretePrototype: 克隆的具体类. • Client: 需要执行拷贝对象的软件对象 然后实现吧
使用代码
为了简化。我以一个著名的偷车游戏作为例子 我们说游戏里有一个注脚。这个主要有着一些定义游戏数据的统计量。保存游戏的时候我们就需要拷贝这个对象，然后序列化到文件中。（仅仅是举个例子，真实的游戏里很少这样做）
下面这个类抽象类就是概念中的Prototype
 接口定义了玩家重要的信息，然后定义了一个Clone方法。然后我们定义一个具体的玩家类CJ。这样我们可以克隆当前对象，然后异步的进行序列化
这个类就是概念中的ConcretePrototype 。这里为了简化也没有其他一些方法了。
现在看看客户端软件的写法

理解深浅拷贝
上面的代码就模拟了原型模式，有一个问题就是我们使用了MemberwiseCopy 方法。而这个方法是创建浅拷贝的。如果对象里包含引用类型，引用类型的地址就会被从前者拷贝到后者。这样。两个就指向了同样的对象。
为了说明情况。我们让主角类包含更多的，叫做AdditionalDetails
 然后抽象类将会一个AdditionalDetails 对象
 具体类既然使用MemberwiseCopy实现拷贝
 问题来了。两份拷贝会指向同一个AdditionalDetials 对象

画个图。看得清楚些
 为了避免这种期刊。我们需要在堆上创建引用类型的拷贝，然后对应赋值
 这样就可以了

注意。当执行深拷贝的时候，可能引用类型来包括引用类型，因此好的做法是用反射。并且递归的拷贝。直到没有引用类型，具体可参考另一文
实现ICloneable接口 ICloneable接口提供了定义拷贝方法的接口。我们可以使用ICloneable 作为概念中的Prototype，我们看一下如果实现ConcretePrototype
 客户端代码如下

Demo下载 [downloadicon href=http://pan.baidu.com/share/link?shareid=86332&amp;amp;uk=1493685990]PrototypeDemo.zip[/downloadicon]
原文地址：Understanding-and-Implementing-Prototype-Pattern-i
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>实现IEnumerable接口&amp;理解yield关键字</title>
      <link>http://leaver.me/2012/10/19/%E5%AE%9E%E7%8E%B0ienumerable%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3yield%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Fri, 19 Oct 2012 07:33:12 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/19/%E5%AE%9E%E7%8E%B0ienumerable%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3yield%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>本文讨论题目的内容。然后讨论IEnumerable接口如何使得foreach语句可以使用。之后会展示如果实现自定义的集合类，该集合类实现了IEnumerable接口。Yield关键字和遍历集合后面也讨论。
背景
一使用集合。就发现遍历集合就跟着来了。遍历集合最好的方式是实现迭代器模式-Understanding and Implementing the Iterator Pattern in C# and C++(这篇文章我过几天翻译一下) ，C#提供foreach来以一种优雅的方式遍历
只要集合实现了IEnumerable 接口就可以用foreach来遍历。
使用代码
首先先看一下内置的集合类如何使用foreach来遍历的。ArrayList实现了IEnumerable 接口。我们看一下
 遍历泛型集合类
Arraylist 是一个通用集合类，遍历泛型集合类也可以。因为这些泛型集合类实现了IEnumerable&amp;lt;T&amp;gt;接口，看一下吧。
 发现了吧。我们自定义的集合类或是泛型集合类应该实现IEnumerable和IEnumerable&amp;lt;T&amp;gt;接口。这样就可以遍历了。
 理解yield关键字
在写个实现接口的例子之前，先理解一下yield关键字，yield会记录集合位置。当从一个函数返回一个值的时候，yield可以用。
如下的普通的方法。不论调用多少次，都只会返回一个return
 原因就是普通的return语句不保留函数的返回状态。每一次都是新的调用。然后返回第一个值。
但是使用下面的语句替换后就不一样。当函数第二次调用的时候。会从上次返回的地方继续调用
显然返回1，2，3，唯一要注意的就是函数需要返回IEnumerable。，然后通过foreach调用。
在自定义的集合类里实现Ienumerable接口
现在如果我们在我们的自定义集合里定义一个方法。来迭代所有元素。然后通过使用yield返回。我们就可以成功了。
好。我们定义MyArrayList 类，实现IEnumerable 接口，该接口就会强制我们实现GetEnumerator 函数。这里我们就要使用yield了。
  之后你就可以用foreach遍历了。
 这个类啊。没写好。也不完整。只要是让你理解。。模拟一下而已。
自定义泛型类里实现Ienumerable&amp;lt;T&amp;gt;接口
 之后就可以使用foreach了。
** 源代码下载**
[downloadicon href=http://pan.baidu.com/share/link?shareid=86013&amp;amp;uk=1493685990]EnumerableDemo.7z[/downloadicon]
原文地址： A-Beginners-Tutorial-on-Implementing-IEnumerable-I
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>模拟Office2010文件菜单的TabControl模板</title>
      <link>http://leaver.me/2012/10/17/%E6%A8%A1%E6%8B%9Foffice2010%E6%96%87%E4%BB%B6%E8%8F%9C%E5%8D%95%E7%9A%84tabcontrol%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Wed, 17 Oct 2012 10:00:24 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/17/%E6%A8%A1%E6%8B%9Foffice2010%E6%96%87%E4%BB%B6%E8%8F%9C%E5%8D%95%E7%9A%84tabcontrol%E6%A8%A1%E6%9D%BF/</guid>
      <description>这是Office2010中的文件菜单点开后的效果。本文我将以强大的WPF来实现类似的效果。希望你能有所收获。而不是只拷贝/粘贴代码而已。
 开始之前。先把TabControl找个地方放着。
 然后会大概是这个效果

为了改变TabControl的显示效果。我们使用模板机制，我们把模板写进一个资源字典里。这样就可以重用了。添加一个资源字典的步骤如下
右键点击工程-添加-资源字典
然后在资源字典里添加一些代码。
 之后，我们为VisualState创建故事板，一个是正常状态。会使得hoverShape的透明度为0.另一个是鼠标悬停的状态。透明度会变成1
 当你运行的时候你会发现没什么变化。我们还要定义被选中标签的VisualState
当添加如下代码的时候 添加一个VisualState组。也就是 SelectionStates ，然后给选中/为选中的状态添加行为/故事板。.这里通过修改透明度来实现一些效果
 现在再运行会发现效果更好了

 还有个小问题，就是那个陷进入的小三角形的背景颜色依然还在。通过在下面添加一个白色的形状。，并且对故事板的选中和为选中状态改变一下透明度就可以了。
 最终效果如下:

源代码地址： [downloadicon href=http://pan.baidu.com/share/link?shareid=85332&amp;amp;uk=1493685990]OfficeTab.7z[/downloadicon]
许可
本文包括源代码和文件在CPOL下授权
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>类型安全的黑板模式（属性包）</title>
      <link>http://leaver.me/2012/10/16/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F%E5%B1%9E%E6%80%A7%E5%8C%85/</link>
      <pubDate>Tue, 16 Oct 2012 12:12:06 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/16/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%BB%91%E6%9D%BF%E6%A8%A1%E5%BC%8F%E5%B1%9E%E6%80%A7%E5%8C%85/</guid>
      <description>有时候对于对象来说。在一个软件中，不直接通过互相引用而做到共享信息是非常有用的。比如像带有插件的软件。可以互相进行通信。假设我们有了很多对象。其中一些包含一些数据。而另一些对象需要消费这些数据 不同的子集，我们不通过对数据生产者和消费者的直接引用来实现，而是通过更低耦合的方式。叫做创建一个“BlackBoard”（黑板）对象。该对象允许其他对象自由对其进行读取/写入数据。这种解耦方式使得消费者不知道也不必知道数据来自哪里。如果想要了解更多关于黑板模式的信息。我们常说的。Google是你最好的朋友。
一个最简单的黑板对象应该是 Dictionary一些简单的命名值的字典。所有的对象共享同一个字典引用。使得他们可以交换这些命名数据。这种方法有两个问题。一个是名字。一个是类型安全—数据生产者和消费者对每一个数据值都必须共享一个字符串标识。消费者也没有对字典中的值进行编译时的类型检查，比如，可能期望一个小数，结果运行时读到了字符串。本文对这两个问题演示了一种解决方案。
背景
最近我在开发一个通用任务的异步执行的引擎。我的通用任务通常有Do/Undo方法。原则上是相互独立的，但是有一些任务需要从已经执行的任务重请求数据。比如。一个任务可以 为一个硬件设备建立一个API，随后的任务就可以使用创建好的API来操作硬件设备。但是。我不想我的执行引擎知道关于这个执行任务的任何信息。而且。我也不想直接手工的就在一个任务里引用另一个任务。
黑板类
黑板类本质上是一个Dictionary的包装类，对外暴露Get和Set方法。黑板类允许其他对象存储并且取回数据。但是要求这些数据使用一个 BlackboardProperty 类型的标识符来表示这些数据是可存取的。BlackboardProperty 对象应该在那些准备读写黑板类的对象之间共享，因此，他应该在那些类中作为一个静态成员。（很像WPF的依赖属性。是他们所属控件的静态成员）
注意：命名安全应该可以通过同样的方式实现。但是但是依然没有解决类型安全的问题。那么。到了主要的部分了。那就是黑板类的代码了
黑板属性（BlackBoardProperty）类
BlackBoardProperty 类 提供了一个标识符来存取黑板对象中的数据。定义了名称和值的类型。也定义了一个默认的返回值。以防黑板类中对应属性没有值。
我承认不是非常有用的代码。但是。能够模拟两个类的使用。 下一个例子会更和现实情况接近。但是肯定是被简化过了的。在下面的例子里。我定义了集中不同的任务。我用这些任务来启动对硬件设备的连接。操作设备。关闭连接。这些任务通过一个执行引擎依次执行，这些任务通过一个公用的黑板类来共享数据。至于这个任务类的和执行引擎（ExecutionEngine）类还是留到另一篇文章中把。
黑板类另一种可能的使用情况就是一个支持插件的软件。如果需要的话允许插件进行通信，这种情况下属性改变的时候能够通知是很有用的。
还有一件重要的事情是注意 BlackboardProperty 实例一般应该作为逻辑上拥有该属性的类的一个静态成员。那么既然那是静态的。同样的BlackboardProperty 实例就可以出现在多个黑板对象里。当某一个给定的属性。黑板对象里没有值的时候。他会请求BlackboardProperty 实例提供一个默认的值。缺省的值可能是一个引用类型，因此，如果你不想在多个黑板对象间共享同一个引用。在创建BlackboardProperty 对象的时候务必使用下面的构造函数。 public BlackboardProperty(string name, Func createDefaultValueFunc) 这就会使得默认的值不会在多个黑板对象间共享。
有意思的地方 我应该说过了。这个方案一部分是受微软WPF中依赖属性的影响。还参考了我前段时间读到的一篇关于枚举类的文章
许可 本文包括源代码和文件在CPOL下授权。
原文地址： Type-safe-blackboard-property-bag
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>如何创建WPF用户控件&amp;在WPF项目中使用</title>
      <link>http://leaver.me/2012/10/14/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAwpf%E7%94%A8%E6%88%B7%E6%8E%A7%E4%BB%B6%E5%9C%A8wpf%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 14 Oct 2012 15:19:24 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/14/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAwpf%E7%94%A8%E6%88%B7%E6%8E%A7%E4%BB%B6%E5%9C%A8wpf%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8/</guid>
      <description>作者给的Demo我合并了下。VS2010直接打开解决方案。二者都有。

介绍 本文展示在WPF中如何创建用户控件并且如果在WPF项目中使用。我将使用VS2008和C#来展示如何创建一个自定义的ToolTip
背景
这篇由Sacha Barber.写的和我的有点像。
使用代码
开始。首先，我们创建一个用户控件。因此，我们选择新建WPF用户控件类库（WPF User Control Library）。

现在。我们可以创建或者编辑XAML代码来创建自定义的用户控件了。我使用XAML来创建自定义的ToolTip。你想做什么随你。
 同时。我们需要添加一些方法和属性来控制这些元素。
 完成之后。我们按Shift+F6快捷键来生成dll文件。现在可以创建WPF项目并且使用我们的控件了。我们选择WPF应用程序项目

然后。我们添加对我们的控件生成dll的引用（注意。其实还可以把这两个项目放在同一个解决方案里。然后此处添加对项目的引用就可以 –译者）

我们将会在XAML窗体里使用自定义的用户控件。因此我们需要添加一些额外的XAML代码。我们在Window元素里添加下面一行。

至少。我们必须有一个Window 元素。。
好。现在我们在XAML中像这样使用控件

最后。我创建了如下的XAML代码：
 再写一些方法来显示/隐藏我们的自定义ToolTip
完了。
Demo下载 [downloadicon href=http://pan.baidu.com/share/link?shareid=83438&amp;amp;uk=1493685990]CustomToolTipDemo[/downloadicon]
许可 本文包括源代码和文件在CPOL下授权。
 原文地址：How-to-Creating-a-WPF-User-Control-using-it-in-a-W
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>WPF绘制圆角多边形</title>
      <link>http://leaver.me/2012/10/13/wpf%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E5%A4%9A%E8%BE%B9%E5%BD%A2/</link>
      <pubDate>Sat, 13 Oct 2012 09:45:40 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/13/wpf%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E5%A4%9A%E8%BE%B9%E5%BD%A2/</guid>
      <description>介绍
最近，我发现我需要个圆角多边形。而且是需要在运行时从用户界面来绘制。WPF有多边形。但是不支持圆角。我搜索了一下。也没找到可行的现成例子。于是就自己做吧。本文描述了圆角多边形的实现，也包括如何用在你的项目里。在Demo里面的RoundedCornersPolygon 类是完整的实现。
下载的Demo包括两部分
1. 通过XAML绘制圆角多边形

2. 运行时创建圆角多边形

背景 多边形可以被认为是沿着一个给定半径的圆的边缘和一些指定点/边。所构成的点的集合。
 在WPF中。你可以给Polygon对象的Points属性添加一系列的点来制作多边形。
XAML方式
C#方式
 上面两个例子会输出下面的矩形

使用代码 我写的RoundedCornersPolygon 类和普通的多边形类很相似。但是有更多的属性来控制圆角。首先。看一个例子。展示一下圆角矩形类的使用
XAML方式
C#方式
输出如下：

多边形有四个主要属性 ArcRoundness 属性指定了从距离LineSegment终点多远的距离开始弯曲，通常和UseRoundnessPercentage 一起使用。UseRoundnessPercentage属性指定了ArcRoundness 值是百分比还是一个固定的值。
举个例子。ArcRoundness 被设置成10，而且UseRoundnessPercentage 被设置成false，那么弯曲将会在距离线段终点10的地方开始。而如果UseRoundnessPercentage 被设置成ture。则会是从线段终点10%的地方开始弯曲。
IsClosed 指定多边形的最后一个点是否和第一个点闭合。为了成为一个多边形。一般应该被设置为true
 Points属性则代表了多边形点的集合。
 如何实现 控件实现了Shape 类，被用来画多边形的形状是一个Path对象。我们会往Path对象里添加LineSegment 和QuadraticBezierSegment 对象。QuadraticBezierSegment 对象表示一个贝塞尔曲线。由三个点定义。更多的信息请查看
对于一个普通的多边形，只有LineSegment是必须的，但是为了设计圆角多边形。就需要贝塞尔曲线了。每一次一个点被添加/一个属性被修改。形状会重绘。做圆角的关键方式就是ConnectLinePoints 方法。
 还有两个方法计算弯曲部分开始的点GetPointAtDistance 和GetPointAtDistancePercent，第一个是以值计算，第二个是以百分比计算。
 结论 依然有很多细节应该完善的。但这仅仅是圆角多边形的一个尝试。比如。在其他情况。每个角应该有不同晚景的圆角，WPF使得一切皆有可能。本文的目的是创建一个大家可以用的圆角多边形，他们可以扩展来满足他们的需求。
Demo下载
[downloadicon href=http://pan.baidu.com/share/link?shareid=82217&amp;amp;uk=1493685990]圆角多边形[/downloadicon]
许可 本文包括源代码和文件在CPOL下授权。
原文地址：WPF-rounded-corners-polygon
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>一步步教你制作WPF圆形玻璃按钮</title>
      <link>http://leaver.me/2012/10/12/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E5%88%B6%E4%BD%9Cwpf%E5%9C%86%E5%BD%A2%E7%8E%BB%E7%92%83%E6%8C%89%E9%92%AE/</link>
      <pubDate>Fri, 12 Oct 2012 09:31:00 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/12/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%95%99%E4%BD%A0%E5%88%B6%E4%BD%9Cwpf%E5%9C%86%E5%BD%A2%E7%8E%BB%E7%92%83%E6%8C%89%E9%92%AE/</guid>
      <description>1.介绍
从我开始使用vista的时候，我就非常喜欢它的圆形玻璃按钮。WPF最好的一个方面就是允许自定义任何控件的样式。用了一段时间的Microsoft Expression Blend后。我做出了这个样式。我觉得做的还行。因为。我决定分享。如我所说。我使用Microsoft Expression Blend来做。但是。我也是用XAML编辑器&amp;ndash;Kaxaml。
2.概述
玻璃按钮样式包含了三层。组织了玻璃效果（Glass Effect）和一个ContentPresenter 来存储按钮的内容。所有的这些层都在一个最外层的Grid里。当鼠标放到按钮上，按下去的时候也定义了一些触发器（Triggers），来增加一些交互。
我把这个样式做成了资源文件。但是这个Key可以删除，来使得所有的按钮都是这个效果。
好我们来看一下这些层次。这些被广泛应用在微软产品中的按钮。
**3.按钮层次 **
3.1背景层
第一层是一个椭圆。其实是一个canvas，一会在上面画反射和折射层，填充的颜色和按钮的背景（Background）关联。
下面是Blend中的截图
图2 
3.1.1折射层
第二层模拟了光从上到下的折射。被放在反射层之前是因为，要达到反光玻璃的效果，反射层必须在按钮的中间某处有一个硬边缘。这一层实际上是另一个椭圆。但是这次。我们使用一个径向渐变（白色-透明）的填充。来模拟光的折射。渐变开始于第一层底部的中央。结束于上面的中间。然而。为了降低折射光的强度。渐变还是开始于椭圆的底部再下一点为好。可以从图上和代码里清晰的看到。 
 3.1.2反射层
第三层是光的反射层。是最难的部分。问题是反射效果不能使用任何标准的形状来画。因此。使用路径（Path）来画反射区域。当时。手工画也是可以的。但老实说。手工画图实在没什么可享受的（除非你是一个艺术家，或者有一个数位板），无论如何。我现在MS Blend中华好一个椭圆并转换成一个路径，然后我使用贝塞尔曲线点调整得到平滑的路径，你可以添加渐变到一个复杂的Path对象上。就像你对其他与定义的图形，比如椭圆，矩形所做的一样。为了得到光泽反射。我额每年需要一个透明-白色的径向渐变填充，从路径的底部开始（也就是按钮的中间某处），结束在顶部。我想如果我是一个艺术家。我会让渐变更准一点。可是我不是。因此。就这样。因为我们要把我们的按钮放在一个Grid里。所有我们设置VerticalAlignment=&amp;quot;Top&amp;rdquo; 这样反射区域在按钮的中间的结束了。
图三 
 最后。我添加一个ContentPresenter 到按钮中间。经验告诉我，内容区域再向下一个像素会使得按钮看起来更漂亮。因此，在这里我用了margin属性（注意。因为内容区域在Grid的中间（Center）。所以2个像素的top实际上是向下移动了一个像素 ）
好了。最后在Blend中看起来大概是这样
图4 
4.添加一些交互性
4.1鼠标悬停效果
为了有鼠标悬停效果，我们需要增加光源的亮度。因此。我们为IsMouseOver 事件定义一个触发器，复制并且粘贴反射和折射层的渐变设置代码。对于折射层。我仅仅移动了渐变的起点向上了一点。在反射层中。我改变了渐变停止点。使不透明的白色多一点。
 4.2鼠标点击效果 对于IsPressed 事件，需要降低光。因此。反向操作即可。折射层中光源下一点。反射层中渐变停止点更加透明一些。
 再说一次。渐变停止点的值靠经验选的。我也不能给出精确的值。
5.使用代码
为了使用这个样式。把定义在GlassButton.xaml 里的样式资源文件并不到你的窗体/页里。然后设置按钮的样式为{StaticResource GlassButton}. 为了设置按钮的颜色。使用Background属性即可。
  6.Demo下载 [downloadicon href=http://pan.baidu.com/share/link?shareid=81378&amp;amp;uk=1493685990]Demo与源代码下载[/downloadicon] 7.许可
本文包括源代码和文件在CPOL下授权。
原文地址：a-style-for-round-glassy-wpf-buttons
 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>自定义WPF LinkLabel 控件</title>
      <link>http://leaver.me/2012/10/11/%E8%87%AA%E5%AE%9A%E4%B9%89wpf-linklabel-%E6%8E%A7%E4%BB%B6/</link>
      <pubDate>Thu, 11 Oct 2012 13:24:02 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/11/%E8%87%AA%E5%AE%9A%E4%B9%89wpf-linklabel-%E6%8E%A7%E4%BB%B6/</guid>
      <description>WPF里是没有LinkLabel控件的。因此我自己写一个。首先。我们看一下WPF中什么类似的组件可以实现这个链接功能
如果你想要模拟一个LinkLabel控件。你可以在TextBlock里使用内联的Hyperlink。像下面这样
你可以使用Label控件。加一个内联的HyperLink，但是我认为TextBlock更好。因为你可以在Expression Blend 中通过InlineCollection 编辑所有子元素的属性
图1
 虽然这种方法也行，但是我还是不太喜欢。因为我觉得我还是写一个类似windows窗体程序中的LinkLabel控件。然后我就做了。首先看一下控件的样子
图2

第一个是默认的LinkLabel控件。第二个是LinkLabelBehavior 属性被设置为HoverUnderline ，第三个的Foreground和 HoverForeground 属性都使用了自定的颜色。
 LinkLabel控件支持的属性
1.Foreground和 HoverForeground属性
允许自定义这两个属性的值
2.LinkLabelBehavior 属性
允许设置下划线的显示与否
3.自定义HyperlinkStyle 属性
你可以使用这个属性给超链接设置自定义的样式。如果你已经自定了Foreground和 HoverForeground。则会被覆盖。
Url 超链接的目标
所有这些属性都继承自标准的System.Windows.Controls.Label 控件
通过Blend/Xaml设置这些属性很简单
图三

然后是控件的使用方法。仅仅添加命名空间到xaml中。然后使用就行了。
 控件的完整代码很简单。就定义一下需要的属性，和控制这些属性应该显示在Blend中的（category）目录位置就行了。
  为了使得内容可以绑定。我使用了Filipe Fortes 实现的BindableRun 我添加BindableRun 到控件模板中
 为了支持主题显示。应该在工程里有个Themes文件夹。包含控件的样式。LinkLabel只有一个样式文件Generic.xaml，因为超链接样式不管当前主题是什么。都是一样的。我不会包含LinkLabel 的模板。
 多看源代码。下载并且开始使用吧。
示例和源码下载
http://www.blagoev.com/blog/post/building-a-wpf-linklabel-control.aspx</description>
    </item>
    
    <item>
      <title>C#制作进度窗体</title>
      <link>http://leaver.me/2012/10/10/c#%E5%88%B6%E4%BD%9C%E8%BF%9B%E5%BA%A6%E7%AA%97%E4%BD%93/</link>
      <pubDate>Wed, 10 Oct 2012 09:07:41 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/10/c#%E5%88%B6%E4%BD%9C%E8%BF%9B%E5%BA%A6%E7%AA%97%E4%BD%93/</guid>
      <description>介绍
这是我在CodeProject上的第一篇文章。我希望对你有用
当我开发软件的时候。我通常因为一个很耗时是任务需要完成。而请求让用户等待，并且通过也允许用户取消。不论我做何种操作（比如下载文件。保存大文件等等）。我都需要做下面几件事：
 通过一个模态对话框来让用户等待操作完成 能让用户看到进度。 能让用户随时取消。 我搜了好久也没找到拿来就能用的窗体控件，也许是我没找到。于是我自己写。。 图1  背景
BackgroundWorker 类包含了我需要完成任务的所有东西。我只需要给他提供一个对话框。
使用代码
ProgressForm 包含了一个BackgroundWorker ，你要做的仅仅就是提供了一个完成工作的方法。
为了开始BackgroundWorker，只需要调用ShowDialog 方法。返回值则取决于任务是怎么完成的。
 最后。任务方法看起来是这样的。
如果你想要改改进度条，或者进度条显示的文本。SetProgress 有一些重载的方法
最后一个可自定义的字符串是：有两个预定义的字符串CancellingText 和DefaultStatusText. CancellingText ，这两个字符串，当用户点击取消的时候显示
如何实现 ProgressForm 紧紧嵌入了一个BackgroundWorker ，并包装进了主函数。
首先。我设计了如图所示的一个窗体，然后。添加了BackgroundWorker。
我们必须把DoWork事件暴露给用户。我添加了一个委托。这样。我可以很容易的访问窗体成员
 好。我们已经有了任务和事件。先爱。我们希望当窗体显示的时候。后台任务尽可能开始。我们在Load事件中写代码
现在写一个方法通知进度。添加代码到ProgressChanged 事件处理程序中
我们快做好了。现在我们添加取消按钮
最后一件事是我们想要当worker完成的时候自动关闭窗体，因为我们的worker通过ShowDialog 方法启动。如果直接接收返回结果会很好
主要的工作就完成了。我添加了一些预定义的字符串啊。如果正在取消。保护状态不会改变。还有传递参数啊。 完整的代码如下：
结论 窗体简单，我通常用。希望对你们也有用
Demo下载
源码和测试下载
许可 本文，包括源代码和文件在CPOL下授权。
 原文地址：ProgressForm-A-simple-form-linked-to-a-BackgroundW 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>C#编写FTP客户端软件</title>
      <link>http://leaver.me/2012/10/09/c#%E7%BC%96%E5%86%99ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Tue, 09 Oct 2012 09:06:16 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/09/c#%E7%BC%96%E5%86%99ftp%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BD%AF%E4%BB%B6/</guid>
      <description>1 介绍 我知道。网上有很多现成的FTP软件。但是。我们也想要了解FTP的一些底层机构，因此。 这个开源的项目在你学习FTP知识的时候也许对你有些帮组。程序的界面看起来像FileZilla，FileZilla虽然流行但是有些bug，当我打开我博客的时候总是有问题。我需要通过FTP连接我的服务器。发送文件，下载文件等等。因为。我决定写我自己的软件来处理所有的情况。FileZilla足够好。但它不是我的。
 2 背景  看看我们已经知道的。我们知道FTP是一个标准的基于TCP网络协议。用于从一个主机向另一个主机传输文件。它是一个C/S架构。
 图2

 FTP程序曾经是基于命令行的。我们仍沿可以通过cmd.exe连接FTP服务器。因为FTP的确可以通过命令来操作。举个例子。我们可以在命令行使用“stor”命令来发送文件。为了完成这些请求。FTP服务器需要一直运行等待即将到来的客户端请求。我们可以从来自维基百科的解释更好的理解FTP：
 客户端计算机可以通过服务器的21端口和服务器通信。叫做控制连接。它在一次会话期间保持开放。第一次连接的时候。叫做数据连接,服务器可以对客户端打开20端口（主动模式），建立一条数据通路，连接上客户端传输数据。或者客户端打开一个随机的端口（被动模式），去连接服务器，来传输数据。控制连接使用一个类似Telnet的协议，被用作客户端和服务器会话管理（命令，标识，密码）。。比如。&amp;ldquo;RETR filename&amp;rdquo; 会从服务器端下载文件。
图三
一个完整的FTP文件传输需要建立两种类型的连接，一种为文件传输下命令，称为控制连接，另一种实现真正的文件传输，称为数据连接。
  服务器 通过三位ASCII的数字状态码，可能包含可选的描述信息，在控制连接上做出回应。比如。“200”或者是“200 OK”,表示上一条命令成功了。数字代表编号，描述信息给出了一些说明（比如“OK”）,或者可能是一些需要的参数(比如需要帐号来存储文件)，那么我们需要怎么做呢。很明显。发送命令，接收“OK”回应，发送数据。接收数据。完了。但是首先需要服务器已经准备好了。FTP服务器可以在主动和被动两种模式下运行。主动模式是基于服务器的连接而被动模式是基友客户端的连接。继续看。
   在主动连接中，客户端把自己的ip和端口发送给服务器。然后服务器尝试连接到客户端，但是可能会因为防火墙的原因而被拒绝。我们在windows上都会使用反病毒/自带防火墙。是吧。那么我们来看看被动模式
 在被动连接中。服务器通过一个“PASV”命令把自己的ip和端口发送给客户端。然后客户端通过该IP尝试连接服务器。对于发送文件非常有用。当我们发送文件的时候。优先使用“PASV”模式，如你们所说。大多数协议。像FTP/HTTP 使用ASCII编码，因为全球可用。因此我们会使用这种编码。你可以从下面得到FTP的命令列表
 主动和被动都是对于服务器端来说的
3 使用代码 现在我们已经为编写软件做好准备了。我们写些有用的代码吧。：）首先。我们“打开文件对话框”，集成到我们的窗体里。
 3.1 资源管理器组件  我们需要一个资源管理器组件在软件界面可以看到我们所有的文件。这样我们才可以选择哪些文件来发送到FTP服务器，新建一个Windows窗体控件库（下载包中提供了）
 图四

 最后看起来样子是上面这样。先添加一个TreeView，一些按钮，和一个搜索功能
TreeNode nodeD = new TreeNode();
nodeD.Tag = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
nodeD.Text = &amp;ldquo;Desktop&amp;rdquo;;
nodeD.ImageIndex = 10;
nodeD.SelectedImageIndex = 10;
TreeView.Nodes.Add(nodeD);   可以从下载包里看到完整的代码。我们还应该处理鼠标单击事件。
 现在我们有了一个资源管理器。还有FTP和VS所需要的所有信息。
首先，我们连接服务器。我们应该怎么做呢？
  我们发送命令到服务器。服务器以他自己的语言来响应。我们需要理解他。响应包括3位数字和一些解释。
  完了。现在我们可以下载，上传，重命名。或者删除了。
  4 FTP命令列表 5 返回码列表  2xx –返回成功 4xx or 5xx – 返回失败 1xx or 3xx – 错误或不完整的回复  第二位定义了错误的类型
 x0z – 语法 – 有语法错误. x1z – 信息 – 请求提供信息 x2z – 连接 – 说明控制或数据连接有问题 x3z – 账户认证 – 登录或者是账户认证有问题. x4z – 未定义 x5z – 文件系统 – 可能是服务器文件系统有问题。   Demo 下载 C#编写FTP客户端
6 许可 本文包括源代码和文件在CPOL下授权。
 原文地址：File-Transfer-Protocol-FTP-Client
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>理解并实现生成器模式</title>
      <link>http://leaver.me/2012/10/08/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 08 Oct 2012 13:11:16 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/08/%E7%90%86%E8%A7%A3%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>介绍 本文讨论生成器设计模式，讨论该模式什么情况下使用，怎么实现。并且。最后会有一个简单的生成器模式的实现。
 背景 当我们的程序需要创建一个对象。而这个对象必须由很多不同的对象来构造的时候。为了构造最后的对象。我们不得不组合那些部分对象。最后我们会发现我们的代码被各种各样的部分对象的细节所弄的难以理解
 为了说明上面的情况。我们做一个手机生产制造系统的例子。假定我们我们有一个已经安装在手机供应商那块的一个系统。现在供应商系那个要根据一些参数来创造一个新手机。比如触屏，操作系统，电池等。如果我们已经有了这些部分的对象，那么上述部分的任意组合将会导致客户端代码复杂难以管理。比如决定生产哪种手机的模块。
 生成器模式目的就是解决上述问题的。GoF定义生成器模式如下：
Separate the construction of a complex object from its representation so that the same construction process can create different representations.
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
  这个定义意味着我们不得不设计这个系统。通过一种客户端仅仅定义参数，而生成器则接管创建复杂对象 的方式。我们看一下生成器模式的类图。

然后看看上图中的每一个类都表示什么
ConcreteBuilder: 创建复杂产品的具体类.将会知道他已经创建的Product（产品），也就是他已经装配了的Product， 客户端通过该类得到Product对象.
Builder: 创建Product的接口
Director: 客户端代码，定义了哪些部分应该被组合在一起来创建具体的Product
Product: 这是通过组合很多部分创建的对象
 使用代码 我们现在跟随上述的定义，然后试着去实现一个基本的生成器模式
 我们先在合适的地方定义Product的不同部分，我们简单的定义一些枚举类型，那么我们就可以通过组合不同的部分创建Product了。
  然后，我们看一下Product类，我们需要有一个可以通过装配创建的Product类，这里我们定义一个MobilePhone类，也就是概念里的Product类了。
    既然我们已经有了Product类，我们来创建Builder吧。Builder类应该提供一些方法可以手机的任何部分。这样我们创建IPhoneBuilder ，也就是概念里的Builder,然后看代码:
  现在我们的Builder接口也准备好了。下一步就是创建ConcreteBuilder了。我们假定供应商事项要一个android手机和一个WP手机。我们就需要两个ConcreteBuilder了。AndroidPhoneBuilder 和 WindowsPhoneBuilder. 在这两个Builder里。我们可以指定每个手机需要的零件类型
   最后我们来创建Director类，我们创建的Director类将会有一个组合函数接受一个IPhoneBuilder 参数，然后调用各自ConcreteBuilder内部的对应方法
   现在我们已经以标准的生成器模式封装了生产复杂Products的方法。现在我们看一下客户端要创建一个Product的时候有多简单。
  现在啊，我们如果还要创建更多的对象，仅仅再需要一个ConcreteBuilder类，其他的代码一点都不会动。客户端代码也更容易来创建复杂Product了。我们看看程序输出。

最后看一下我们通过生成器模式写的程序的类图。

Demo下载 Builder Pattern 
 许可 本文包括源代码和文件在CPOL下授权
原文地址：Understanding-and-Implementing-Builder-Pattern-in
 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>接口VS 委托</title>
      <link>http://leaver.me/2012/10/07/%E6%8E%A5%E5%8F%A3vs-%E5%A7%94%E6%89%98/</link>
      <pubDate>Sun, 07 Oct 2012 08:31:54 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/07/%E6%8E%A5%E5%8F%A3vs-%E5%A7%94%E6%89%98/</guid>
      <description>背景 对于指定的任务有不同的方案可供选择，通常是很好的。因为可能某一种方案会更加适合该任务，但是有时候做决定会很难。因为这些不同的方案有其各自的优缺点。
我经常会停下来好好想想，是不是接口比委托更适合或者是更不适合某个任务。有时候我甚至会回去看我写的代码，这些代码刚开始使用委托来实现，我后来用接口替换掉。因此，是时候写篇文章来阐述一下这两种技术的优缺点了。
 性能 我经常看到有人问接口是不是比委托更快啊。或者是不是相反。通常。别人给的答案会是：
 接口更快。委托相当慢 委托更快，因为他们是指向方法的指针，接口则需要一个v-table(虚函数解析表)，然后找到委托 他们一样快，但委托更容易使用   好吧。那些都是错的。也许在.Net 1中。委托真的很慢。但是事实是：
 委托执行（execute）的时候更快 接口获得（get）的时候更快 在下面这段代码中：   我们将得到一个Action(委托类型)来调用SomeMethod。问题是：委托是包含被调用方法的实例和指针的引用类型。而不仅仅只是一个指向方法的指针，通过引用类型，委托需要分配内存，因此，每一次你把一个方法变换成一个委托的时候。都会分配一个新的对象。
如果委托是一个值类型。会有些不一样。但是他们不是。。
另一方面，如果我们这样写代码：
 如果实现了IRunnable接口的对象。我们简单通过一个转换得到同样的引用。没有涉及内存分配。我们将可以通过下面的代码来进行速度比较：
对于委托：
 对于接口
我知道接口会更快。不是因为他们执行更快。而是因为每一次迭代，一个新的Action委托都会被分配。 但是。如果把委托和接口的获得语句放在循环之外。委托会更快一些。
当创建事件的时候。举个例子。我们在给事件添加委托的时候，就只添加一次。这样。即使事件被触发再多次。也只进行了一次内存分配。
那么？谁赢了？ 好。对于事件，委托将会更快些。
但是。在说委托更好或是更快之前，我们再看另一种情况。
 匿名方法 在我看来，匿名方法是委托最糟糕的使用。但是同时。也正在变成最普遍的用法。
当你像这段代码这样调用的时候
事实上，编译器将会创建一个接受参数i的方法实例，然后创建另一个实例（即委托）来引用这个实例。
如果用接口来替换的话。编译器将指挥分配单一的对象，该对象实现了接口
 可能的抱怨 一些人也许对那个接受参数i的方法实例的问题有所疑惑。他们可能认为，在每一次迭代中。实例里面的之被改变了。也许编译器可以优化这个委托的内存分配。实际只分配了一次。
好把。对于委托的内存分配我不知道。但是。对于要分配一个接受参数i的单一实例，确实真的。也是一个bug。如果MethodThatReceivesADelegate 把委托传递给另一个线程。其他的线程也许会接收到错误的i值，在.net 4.5中。这块不会出错。因为。每一次迭代。一个新的对象被创建。这就能保证当委托被传递到另一个线程里的时候。结果总是正确的。但这也就意味着每次都会有一个新的委托会创建。
如果MethodThatReceivesADelegate 仅仅使用委托一次。使用接口也许更好。不幸的是。我们没有办法实现匿名接口。
好。如果是为了方便。委托更好。但是如果要求性能。在这种情况下。接口会更好。因为避免了一次不必要的内存分配。
事实上，我创建了IRunnable接口是为了强制使用者实现了一个新的类型，而不是使用匿名委托。这样就可以解决在for循环（或是任何在foreach里使用的任何值）i值可变的问题，同时也有一定的性能提升。。
 调用和动态调用  现在我们知道有匿名委托，但是没有匿名接口，只使用一次的情况下，接口将会比委托有更好的性能。因为只请求一个对象而不是两个。
这让我开始考虑，当一个方法接受一个只会执行一次的方法作为参数的时候，我应该使用委托还是是用接口。
但是。更多的性能相关的情况下我们可以这样用。。
你是否曾经有过要用动态调用代替直接委托调用的情况？一般是在编译时并不知道委托的参数类型的情况下。
好。当有一个接口。在接口的方法里有一个方法调用的参数类型未定。我不知道为什么。但是反射调用和委托的动态调用都极慢。比直接对参数做转换都慢。而数组长度验证。然后放到一个try/catch块里会抛出TargetInvocationException 异常。
因此。如果你有类似下面的代码：
{
object DynamicInvoke(params object[] parameters);
}IDynamicInvokable
{
void Invoke(T parameter);
}注意：我讨厌泛型这个名字。对于我来说。IDynamicInvoke 是调用方法最泛型的的途径，而IAction&amp;lt;T&amp;gt; 是类型接口，因此，我我说泛型的时候。我其实是在说更加普遍无类型的调用泛型。而不是类型指定的泛型。
那么，如果对委托做上千次调用。但是使用DynamicInvoke 代替Invoke，接口会做的更好
我又一次的问我自己。匿名委托的简单性值得吗？仅仅为了更好的性能我就把让我的用户对我方法的调用变得困难？并且这真的会影响到程序的整体性能吗？
 泛型，差异，无类型的使用  我刚刚说我讨厌泛型的名字。因为使用泛型的代码通常是有类型的代码，而我们也许需要的无具体类型的代码，我认为这样更加泛一些。
但是。让我好好讨论一下.net的泛型。假设你知道一个委托的参数数目，但是你不知道具体的类型，这和DynamicInvoke 是不一样的。因为这个方法。简单的把所有的参数当成一个数组。
泛型具化或者是相反可以有一些帮助。但是很小。
比如。我们可以把 Func&amp;amp;lt;string&amp;amp;gt; 当成 Func&amp;amp;lt;object&amp;amp;gt; ``，或是把``Action&amp;amp;lt;object&amp;amp;gt; 看成 Action&amp;amp;lt;string&amp;amp;gt;
理由很简单，当返回一个值的时候（``Func``的情况），``string``是一个``object``。将不会做任何转换。将会简单地返回一个``string``，调用这会看成一个无类型的``object``。但是可以。而在``Action``这个情况下。它需要一个``object``，而``string.是可用的object，所以也可以。
但是。如果你想要把Func&amp;amp;lt;int&amp;amp;gt; 当作Func&amp;lt;object&amp;gt;。更广泛一点。想把所有的参数转换成object，可以吗？
答案是否定的。即使int在.net中也是object。但是。所有的值类型需要装箱。这个一个额外的动作。想要简单的把int作为object，而不进行装箱操作。将会引发很多问题。这也就是他不被支持的原因。
但是如果设计的好，接口会有个好处。我个人的原则是：没当有一个泛型类型的时候（可能是类或是接口），我会创建更泛型的一个接口，好吧。一个无类型的接口。该接口有所有的方法和性，但是使用object代替泛型参数类型。他会作为泛型类型的基类接口。
也就是说。如果我有一个IAction&amp;lt;T&amp;gt;，我会创建一个IAction接口。如果有IAction&amp;lt;T1, T2&amp;gt;，我会创建IAction2接口。
事实是：我更愿意Action&amp;lt;int&amp;gt; 能够被看作Action&amp;lt;&amp;gt;，然后让。Net可以知道我想要使用一个无类型的泛型委托。但是.net 不支持对泛型类型的无类型的使用。所以。我添加一些额外，有着无类型方法和属性的接口，到我的泛型类和接口里。然后就可以了。但是。对于委托来说这是不可能的。因此，此处接口更好。
 不同的用法 我们已经讨论过Invoke（调用）和DynamicInvoke（动态调用）了，那么TryInvoke呢？
我的上两篇文章讨论了这种转换。我们下面会回到那种情况下。
如果我们使用Converter&amp;amp;lt;TInput, TOutput&amp;amp;gt; 委托。转换可能正常也可能抛出一个异常。如果代码可以处理不正确的值，那么抛出异常对于表示转换失败就不合适了
我考虑创建另一个委托（TryConverter），这个委托返回一个bool值表示转换是否正常。并且使用一个out参数来表示转换结果
对于像Int.TryParse这样的异常无关的转换。将会很好。但是。如果没有（比如当TryConverter转换完成的时候）。我们需要捕获返回false的异常。
这个问题并没有真正产生。这个问题我正在构造来抛出该异常。在这种情况下。异常将会被捕获。然后返回false，然后又引发另一个异常。。太恐怖了。
但是接口可以解决这个问题。通过接口我们可以定义两个方法。Convert 和TryConvert.
这样Convert可以用来进行抛出异常的转换，而TryConvert则用于不抛出异常的转换。
如果仅有一个引起一个异常的转换，那么TryConvert将会被强制捕获异常，如果有一个不引起异常，并且可能失败的转换，那么Convert将需要检查然后引起异常。但是我们要避免那种捕获一个返回false的异常。然后又抛出另一个异常的情况。
这种复杂性使得接口成为最佳解决方案。没有一个同等的委托解决方案，能够确定的比TryConvert给出更好的性能
对于那些读过我其他文章的人。你可以等Converters的更新。更新会使用接口来解决。Convert和TryConvert都会实现，作为一个无类型的接口的功能。并且CastedGet将会被淘汰。
结论  我依旧问我自己。当一个方法接受一些参数。但只是使用一次。接口更快。委托则支持匿名。我到底该用哪一个。
对于多数情况下的事件。委托更好这毫无疑问。但是更多的情况下（通常意义上，当我注册委托并且允许用户能够找到他们的时候）我会用接口替换掉委托，因为后者支持更好的类型或无类型的支持。更易使用并且性能更好。
以一些关键点结束吧。
 委托：  引用类型，因此分配一个完整的对象引用到一个方法。 当你编译时就知道参数类型的使用调用最快。 允许使用匿名委托，简化了单行或是小的委托的创建。 可以不用创建新类型引用到一个私有的方法上。   接口：  不分配新对象。因为获得很快。 对于单一用例的情况。更快。金辉创建一个对象而不是两个。 如果设计的好，允许无类型的泛型使用，并且比委托的DynamicInvoke更快。 如果设计的好。泛型接口可以被无类型的接口（该接口有着相同的方法签名和参数）访问，通过object改变泛型参数。 允许不同的调用（比如Convert和TryConvert） 对于已知的参数类型调用会慢一些。 不支持编译时的匿名使用 即使只需要其中的一个方法。也需要创建完整的类型。   例子</description>
    </item>
    
    <item>
      <title>YAXLib---- XML序列化神器</title>
      <link>http://leaver.me/2012/10/05/yaxlib-xml%E5%BA%8F%E5%88%97%E5%8C%96%E7%A5%9E%E5%99%A8/</link>
      <pubDate>Fri, 05 Oct 2012 16:24:31 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/05/yaxlib-xml%E5%BA%8F%E5%88%97%E5%8C%96%E7%A5%9E%E5%99%A8/</guid>
      <description>今天早上翻译了Yet-Another-XML-Serialization-Library-for-the-NET，刚开始以为很短。翻译着发现不对。。然后你不逼你自己。怎么知道自己做不到。于是。将近4个小时把30页的文档翻译完了。因为文章很长。所以本文只列出前两部分。我把翻译好的做成了pdf，
文档下载：XML序列化神器
1 介绍 在本文中，会把要提到的XML序列化库叫做YAXLib，我们知道。.Net 还是提供了一些序列化功能的，尤其是XmlSerializer，该类被程序员广泛使用用来序列化对象成XML，当然，反序列化也是可以的。我认为XmlSerializer类的问题有几下几点
 程序员不能自由的选择生成的xml的结构 不支持序列化一些集合类，比如Dictionary&amp;lt;,&amp;gt; 或者IEnumerable&amp;lt;&amp;gt;的属性 当反序列化的时候，如果缺失了一些域，则反序列化失败，这就使得用来存储一ixekeyi被用户编辑的配置文件变得不合适了。   2 为什么使用YAXLib YAXLib解决上述问题的特点
 程序员可以决定xml文件的结构，一个属性可以是一个子元素，或者是其他属性的属性，或者是一个在类中没有对应属性的元素。 集合类也可以被序列化成一个逗号分隔（也可以是其他任何分隔符）的数据项列表，而且。为Dictionary&amp;lt;,&amp;gt;对象实现了一些特殊的格式化功能，这样，使得程序员可以完全控制生成的xml文件的结构 他支持System.Collections.Generic 命名空间中的所有泛型集合类（像Dictionary, HashSet, LinkedList, List, Queue,SortedDictionary, SortedList, 和 Stack） 和在System.Collections 命名空间中的非泛型集合类（ ArrayList, BitArray, Hashtable, Queue, SortedList, 和 Stack）非泛型集合类可以包含多种不同的对象，而且，库还支持序列化和反序列化一维，多维，不规则的数组。 支持通过对基类/接口的引用，实现对一些对象集合的序列化和反序列化。 支持多级反序列化 程序员可以为生成的xml提供注释 当进行反序列化的时候，程序员可以选择性对于那些与类的属性相关，但没有出现在xml文件中的数据应该如何处理。这种情况下可以看错是一个错误，然后类库抛出一些异常，或者记录错误，或者可以被看成一个警告，然后用程序员预定义的值赋给对应的属性，而且，程序可以可以选择忽略这个问题，相关的异常将既不抛出也不作任何记录。请查看保留空引用标识那一节 看看什么时候可以忽略孤立的数据也许对你有帮助 程序员可以自己选择错误处理规则，对于数据敏感的应用程序，程序员可以选择在任何异常的情况下，库都应该抛出并且记录异常，对于其他的一些情况（比如要求不那么高的配置文件的存储），程序员可以选择把异常仅仅看成一个警告，仅仅记录一下，让程序的其他部分继续运行。 文档下载：XML序列化神器  著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>简单扩展方法增强代码可读性</title>
      <link>http://leaver.me/2012/10/04/%E7%AE%80%E5%8D%95%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</link>
      <pubDate>Thu, 04 Oct 2012 09:03:48 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/04/%E7%AE%80%E5%8D%95%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</guid>
      <description>本文技术含量不高，但是思路可以借鉴。。
介绍
当你处理计时器，时间间隔，或是其他关于日期的计算的时候。你必然会使用TimeSpan类。
我觉得写出下面的代码可读性并不好。。
而下面的代码就要好一些
** 扩展方法**
使用这些扩展了int类的方法。可以使得创建TimeSpan可读性更好
许可
本文所有源代码包括文件在CPOL下授权。。
原文地址：Simple-extension-methods-for-code-readability
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！
   </description>
    </item>
    
    <item>
      <title>11个高效的VS调试技巧</title>
      <link>http://leaver.me/2012/10/03/11%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84vs%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Wed, 03 Oct 2012 10:45:15 +0000</pubDate>
      
      <guid>http://leaver.me/2012/10/03/11%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84vs%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
      <description>介绍
调试是软件开发周期中的一个很重要的部分，有时很有挑战性，有时候则让程序员迷惑，有时候让程序员发疯，但是。可以肯定的是，对于任何不是太那个微不足道的程序来说，调试是不可避免的。近年来，调试工具的发展已经使得很多调试任务简单省时了。
本文总结了十个调试技巧，当你使用VS的时候可以节省你很多时间。
1. 悬停鼠标查看表达式

调试有时候很有挑战性，当你步入一个函数想看看哪块出错的时候，查看调用栈来想想值是从哪来的。另一些情况下，则需要添加一些监视表达式，或者查看局部变量列表，这通常还是花费一些时间的，但是。如果你把你鼠标指向你感兴趣的一个变量。你会发现事情简单多了。而且，类和结构体可以通过单击展开。这样。你就可以方便快捷的找到你想查看的变量了。
2. 实时改变值  调试器不仅仅是一个分析程序崩溃或是异常结果的工具了，许多bug都可以通过步入新写的函数，检查函数是否如期望的那样运行来预防。有时候你可能会好奇“如果条件为真函数会正确运行吗”大多数情况下，根本不需要改变代码重启挑起，仅仅把鼠标悬停到一个变量上，双击值然后输入一个新值就可以了。。
3．设置下一条语句  一个典型的调试情况就是通过单步跟踪分析为什么一个函数调用失败了。当你发现一个函数调用的另一个函数返回错误的时候你会怎么做？重启调试？有更好的方法。拖动这个黄色的语句标识到你想下一步执行的语句前就可以了。比如你刚才失败的那块，然后步入。简单，不是吗？
4.编辑然后继续  调试一个复杂的程序，或是一个插件的时候，在一个被调用很多次的函数处发现一个错误。但是不想浪费时间停下来，重新编译然后重新调试。没问题，仅仅在该处改正代码然后继续单步就可以。VS会修正程序然后继续调试不需要重启
注意，编辑然后继续有大量的已知限制，首先，64位代码是不行的。如果他如果为你的C#程序工作。就去工程设置的生成选项，然后目标平台为x86.不要担心。发布版的目标平台和调试的时候是分开的。可以被设置为任何平台。。
第二．编辑然后继续改变在一个方法里应该是局部的。。如果你改变了方法签名，添加一些新方法或是类。你就不得不重启程序了。或者撤销改变来继续。改变方法也包含lambda表达式隐式修改的自动生成的代理类，因此也不能继续。
5.方便的监视窗口  大概现代的调试器都有一个监视窗口，无论如何。VS允许你简单的添加或移除变量。单击空行，输入你的表达式按下回车，或者是在不需要的表达式上按下Delete键就可以删除了。 而且。从监视窗口你不仅仅可以看到“正常”的变量。你可以输入$handles 来追踪你的程序打开了多少句柄（可以方便的修复内存泄漏） ，输入$err 可以看到上一个函数的错误码，然后使用工具-错误信息可以看到更详细的描述，或者输入@eax（64位是@rax）来查看包含函数返回值的寄存器。
6.带注释的反汇编  使用交互式的反汇编模式可以使得优化程序的关键部分变得很容易，VS给出对应你代码每一行的汇编指令，并且运行单步运行。同时，可以在任何位置设置断点。而且，表达式的查看和修改也像在C++代码里一样
7.带有栈的线程窗口  调试多线程的程序是痛苦的。。或者也可以是很有趣的。取决于你的调试器。VS2010真正优美的特性是线程窗口的栈视图，通过窗口的调用栈你可以方便的总览线程。
8.条件断点  如果你尝试通过断点再现一个罕见的事件，该情况引发了一些严重的错误。你可以添加条件断点。定义一个断点的条件，然后如果条件不成立，VS会忽略该断点
9.内存窗口  有些bug由不正确的结构体定义引起，忽略的对齐属性等等。查看内存中的内容可以定位然后修复bug。VS提供了一个放百年的内存窗口，可以把值以8/16/32/64位的形式展示。还有浮点值。也允许实时改变他们。就像在文本编辑器里一样。
10.转到定义  这个特性不是直接关于调试的，而是关于浏览大项目的。如果你尝试找到一些不是你自己写的代码中的错误，快速知道“这个类型是什么”或者“这个函数是干嘛的”，可以节省很多时间，VS通过一个转到定义命令方便了你。
11.命令窗口  第十一的技巧chaau已经建议过了。确实可以节省很多时间，VS支持命令窗口，可以通过，视图-其他窗口-命令窗口来启动。一旦激活，你可以输入不同的命令来自动化调试。举个例子。你可以通过如下命令 简单的模拟MFC COleDateTime 变量。
许可 本文包括源代码和文件在CPOL下授权。
 原文地址：10plus-powerful-debugging-tricks-with-Visual-Studi
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>CSV导入导出工具</title>
      <link>http://leaver.me/2012/09/30/csv%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 30 Sep 2012 22:33:19 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/30/csv%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%B7%A5%E5%85%B7/</guid>
      <description>介绍
本文介绍并且实现了在平面文件CSV和SQL server之间的导入导出功能。使用VS2005写的。使用了.net 2.0
本文基于前一篇文章：从CSV导入数据并存储到数据库，本文包含了新功能，比如，导出功能，在数据库创建表，批量拷贝。接下来的例子中有很多注释。
导入
通过ODBC驱动连接到一个CSV文件，然后把文件读到一张表了（基于前面提到的那篇文章） 使用不同的编码和不同的行分隔符（基于前文） 加载CSV文件到DataSet（基于前文） 如何显示对CSV文件的预览（基于前文） 通过SqlBulkCopy的对象向SQL server转移数据，原始数据是DataSet实例
使用结构表，基于CSV文件，创建一个新表 使用事件来处理批量拷贝的进程 导出
浏览SQL 数据库中的用户表 使用不同的编码和分隔符 使用SqlDataReader读取数据，使用StreamWriter转移数据到平面文件
 使用
 下载工程 新建一个数据库，或者使用一个存在的数据库 修改软件中的数据库连接字符串，在prop.cs文件中  运行工程  一些代码段 加载CSV到DataSet中
通过SqlBulkCopy从ODBC连接中转移数据到数据库
基于结构表创建表
获取数据库中用户表名
通过StreamWriter写数据
Demo下载 CSV_import_export 许可 本文包括源代码和文件在CPOL下授权
原文地址：C-CSV-Import-Export</description>
    </item>
    
    <item>
      <title>ListView布局管理器</title>
      <link>http://leaver.me/2012/09/29/listview%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Sat, 29 Sep 2012 10:14:54 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/29/listview%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>介绍 使用ListViewLayoutManager 可以控制ListView/GridView列的布局
 固定列宽：有着固定列宽的列 范围列宽：有着最小最大宽度的列 比例列宽：成比例的列宽  范围列宽可以限制列的宽度，也包括填充列的剩余可视区域。
据我们了解的Html中的表格和Grid空间。比例列以一个百分比来定义列宽，以下几个因素共同确定了比例列的宽度。
 垂直ListView滚动条的可视与否 ListView控件宽度的改变 非比例列宽度的改变  本程序支持通过XAML或是后台代码来控制ListView。如果通过XAML来控制。则允许ListViewLayoutManager 被附加到一个存在的ListView控件上。
ConverterGridColumn 类通过接口IValueConverter 提供了对象绑定。使用ImageGridViewColumn 类则允许通过DataTemplate（数据模板）将列显示成图片等。
在 User Setting Applied中，我展示了如何固定ListViewlieder顺序和大小
XAML中ListView/GridView布局 固定列 下面的例子展示了通过XAML使用固定列宽控制列
设置附加到ListView控件上的ListViewLayoutManager 的Enabled属性为True。然后FixedColumn.Width 就会阻止鼠标拖动改变列的宽度。
比例列
下面的例子展示了使用XAML通过比例来控制列
对比Grid控件的RowDefinition.Width 属性，ProportionalColumn.Width会计算百分比。简单来说，就是上面的例子中Name列会占到总宽度的25%，而City列占到75%。 与固定列相似。鼠标将不能改变列的宽度。
范围列
下面的例子展示了使用XAML通过最小/最小宽度来控制列
第一个范围列的IsFillColumn 属性被设置为True，因此将会自动改变大小来填满剩余的空间，而如果ListView包含一个比例列的话，范围列将不会填充
通过鼠标可以拖动范围列的宽度。鼠标指针会有一些提示。。
组合使用
在真实的世界里。组合使用很普遍。他们的顺序可以多种多样。
使用后台代码控制ListView/GridView布局 定制列的效果 类ConverterGridColumn 作为一个基类，用来绑定列到独立的对象。
列以图片展示 ImageGridColumn 作为一个基类，用来绑定列到图片
有意思的地方 作为ListView控件的核心部件- ListViewLayoutManager 有以下的功能 阻止改变固定列和比例列的宽度 强制了范围列的范围 随着ListView控件的改变而更新列布局 随着某一列的改变而更新布局
为了正确的接收到请求的信息，分析ListView控件的可视树是很有必要的,Thumb对象提供了列宽改变的事件。而为了正确的展示鼠标指针，PreviewMouseMove 和PreviewMouseLeftButtonDown 事件都会被处理
当Viewport控件大小改变（ScrollChangedEventArgs.ViewportWidthChange）的时候，会触发ScrollViewer 控件的ScrollChanged 事件 通过使用DependencyPropertyDescriptor 可以追踪 GridViewColumn的宽度改变。并发出通知。
为了可以集成进已有的系统，列数据被放置在附加属性里。使用DependencyProperty.ReadLocalValue()方法会检测当前的属性是否在同一个对象里。
类ConverterGridViewColumn 同时使用一个简单的绑定。展示数据转换（IValueConverter接口）
类ImageGridViewColumn 在数据模板中使用FrameworkElementFactory 来动态嵌入图片，缺省情况下，在ListView/GridView控件中的图片会自动拉伸（Image.Stretch属性），因为数据模板中的图片是动态创建的。模板元素的值需要使用绑定来制定
许可 本文及所有代码和文件在CPOL下授权
Demo下载 ListView LayOut
原文地址：ListView-Layout-Manager 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>从数据库读取图片发生“无效的参数”异常</title>
      <link>http://leaver.me/2012/09/27/%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%8F%91%E7%94%9F%E6%97%A0%E6%95%88%E7%9A%84%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Thu, 27 Sep 2012 19:47:39 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/27/%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%8F%91%E7%94%9F%E6%97%A0%E6%95%88%E7%9A%84%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8/</guid>
      <description>介绍 我发现对于很多人来说，当从数据库里载入一张图片然后重新创建成一张图片显示的话会有这样一个问题&amp;mdash;-当他们尝试重新创建新的图片的时候，会抛出一个“无效的参数”异常
因此，本文介绍该异常如何产生。并且我希望未来当我或是你发生这个错误的时候还能有所帮助。。
背景 存储图片到数据库里面是一个很有效的想法。很多人在一些场合都会这样做。的确，这是一个很好的想法。在图片很小的情况下，或者图片不是太多。在这两种情况下，当你需要图片的时候，你会实时去加载它们。而当你不需要的时候如果从数据库里加载图片会浪费很多带宽。并使得你的程序有一些慢。
但问题是这种方法也很容易发生错误。&amp;ndash;尤其是你使用字符串连接，然后组合到你的SQL语句里面—并且这个错误只有当你打算使用存储的信息的时候才会发生。然后，看起来似乎是你的读取代码写错了&amp;mdash;不可能—它是正常的。我在其他地方都可以的。。
从数据库里加载图片 重数据库里读取一张图片然后转换成图片显示是很简单的。
将会抛出一个异常—无效的参数
只有当你真正看了从数据库里返回到data里的数据-而不是简单的瞄了一眼调试器，你才能注意到是什么原因。。
它看起来不像是错的，所以它可能就是你想要的。-虽然21字节是一个很大的线索：你的图片可能只有21字节长？那图片可真小。。
但是，上面的是可以读懂的。。稍微练习一下。。每个字节是一个ASCII码。。
简而言之，你从数据库里得到的数据是一个人类可以读懂的字符串，意思是是
当这个Image类试图把它转换成一个图片的时候，必然是不可能的。抛出异常就是必然的了。。代码是正确的。data才是问题所在。
保存图片到数据库 这才是引发问题的地方。 通常。这是因为把字符串连接起来构造SQL语句引起的。
不要在SQL语句中包含image对象—它会调用Image的ToString方法。而这个方法会返回
因此你的上一条语句其实就相当于
存储并不会有什么问题—但是事实上只是把Image的类型名保存了。而你傻傻的以为是图片数据本身。
这还不是唯一的一个不让你直接连接字符串构造SQL语句的原因，如果你想知道其他原因。 使用Google 搜索Bobby Tables，&amp;mdash;这不是闹着玩的。。
好了。其实把代码写正确也不难，虽然可能得多花一些时间。但是，它可以帮助提高代码的可读性和可靠性。而你要做的就是使用一个参数化的查询。
首先，把图片转换到一个字节数组里。</description>
    </item>
    
    <item>
      <title>C#使用Graphics创建饼图</title>
      <link>http://leaver.me/2012/09/27/c#%E4%BD%BF%E7%94%A8graphics%E5%88%9B%E5%BB%BA%E9%A5%BC%E5%9B%BE/</link>
      <pubDate>Thu, 27 Sep 2012 13:47:25 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/27/c#%E4%BD%BF%E7%94%A8graphics%E5%88%9B%E5%BB%BA%E9%A5%BC%E5%9B%BE/</guid>
      <description>介绍 这个程序是使用C#中的Graphics来创建一个饼图的，我已经尽我所能写的很好了。如果你有任何建议可以分享给我，这样我也能从中学习。
使用代码 最近我迷上了Graphics类。我仅仅体验了一下Graphics的DrawPie() 和FillPie() 方法。
最为一个简单的Demo，我创建一个有着五个文本框的窗体，一个按钮，一个图片框。一会我就把饼图画在图片框里
 在创建一个饼图之前，我们头脑里要有这个意识。我们不能创建一个不符合常规的圆，创建圆我们需要度数信息。
为了转换度数。我们首先把给定的值做个求和。然后得出文本框里所有值的和。然后呢。用每个值除以总值再乘以360度。 代码如下：
值转换完毕后。我们可以创建Graphics类的实例了。
然后我们需要创建一个矩形区域，在这个矩形区域里绘制饼图。
前两个参数定义了矩形左上角的坐标，后两个分别定义了举行的宽和高。
为了能够比较清晰的看出饼图各部分的比例。我们需要创建五个笔刷。
现在我们可以开始创建我们的饼图了。graphics.FillPie();方法接受四个参数
 笔刷，用来填充扇形 矩形：饼图将被创建的区域。 开始角度：饼部分的开始角度 覆盖角度：饼部分扫过的角度  一般来说graphics.FillPie();方法并不是创建一个完全的饼图，而是创建饼图的一个扇形部分，我们会创建一系列的扇形最终看起来像是一个饼图。
上面代码的第一行将会创建第一个红色的扇形。起点是0度，并且创建一个计算好的扇面。 之后，在第二行，我们的扇面的起点就会接着上一步的结束的位置，也就是deg1 ，第二行，我们的起点就会是 deg1+deg2
这段代码如你所见，可能不是最优的。我们创建了五个不同的笔刷。和不同的浮点数，而这些操作可以用循环完成。。
我故意没有这样做。因为，这样做了就可能使问题复杂化。下面是使用循环和数组完成相同的工作。
 首先我创建一个整型数组，数组元素个数等于列表框里的数目。然后我使用一个循环计算了所有值的和。 然后。我创建了一个颜色的数组，这里我建议不要创建一个多于6个扇形。。不然看起来就连在一起了。。 第三步呢。。我再次使用循环去把值转换成度数。fDegValue 用来保存每次计算的度数。在我们前面的例子里。我们需要把前面几个值加起来作为下一个扇形的开始。而这里。我们使用fDegSum 来保存前面的和就很好了。
本文很简单，也就使用Graphics创建一个饼图而已。如果是要创建一些专业的图表就要用到.net提供的图表控件了。
下载：源代码和Demo
原文地址：Create-Pie-Chart-Using-Graphics-in-Csharp-NET 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>AvalonDock 2.0入门指南第一部分</title>
      <link>http://leaver.me/2012/09/26/avalondock-2.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 26 Sep 2012 16:38:26 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/26/avalondock-2.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</guid>
      <description>AvalonDock 2.0可以用来为WPF创建一个类似Visual Studio的界面，深入理解如何使用AvalonDock进行开发是很重要的。
在这个入门指南里，我将演示如何开始使用AvalonDock，下面的文章都是基于2.0版本的。并且不能用于早期的版本。
AvalonDock是一个组合的布局模型，很多的控件都在视图上显示，一个DockingManager 类也显示在停靠区，用于可以拖拽文档和工具。
从下面这个截图中我们可以理解AvalonDock组件
 DockingManager 这是AvalonDock中的核心控件，它将包含的窗格排序，处理飞出的窗格，还有浮动的窗口。在上面这个图中，DockingManager 对象包含了所有空间（WPF控件），从顶部的工具栏到底部的状态栏都算。同时。DockingManager 也可以处理保存和恢复布局。
LayoutPanel 这个面板用来管理在一个方向上的子窗口（通过Orientation属性来选择方向），并且在它们之间添加了一个大小调节控件，在一个Orientation属性是Horizontal（水平）的LayoutPanel 上，排列了三个窗格。一个LayoutAnchorablePane在左，一个LayoutDocumentPane在中间。一个LayoutDockablePane在右边。
LayoutDockablePane 这个布局元素包含一个LayoutAnchorable对象的集合。通过它用来管理想TabControl这样的控件，在上面的截图中，LayoutDockablePanes是在左边的&#39;Strumenti&amp;rsquo; 和 &amp;lsquo;Progetti&amp;rsquo; (工具和项目) 和在右边的&#39;Classi&amp;rsquo; 和 &amp;lsquo;Proprieta&amp;rsquo;&amp;rsquo; (类视图和属性视图)的容器，一个LayoutDockablePane可以自动隐藏，就像&#39;Errori&amp;rsquo;(错误)和&#39;Lista Azioni&amp;rsquo;(操作列表) and &amp;lsquo;Uscita&amp;rsquo;(输出)。并且LayoutDockablePane可以被拖动到DockingManager上，成为一个浮动窗口或者附着到它的父控件DockingManager的边缘上。
LayoutDocumentPane 通常包含文档（DocumentContent类型）的一种窗格，但是其实也可以包含像上面提到的工具视图和类视图这样的DockableContents。在一个文档里。LayoutDocumentPane 被放置在ResizingPanel（水平方向）里。ResizingPanel则是上卖弄提到的在两个DockablePane中间的区域。注意。文档窗格是不能被移动的。
LayoutAnchorable 一个停靠内容，是软件控件的容器，总是被包含在一个窗格里（LayoutAnchorablePane或是LayoutDocumentPane），在截图里。LayoutAnchorable是一类对象（包含一个SharpDevelop对象），工具对象，但是错误窗口（它处于自动隐藏状态，被好办在一个自动隐藏窗格里）不是。LayoutAnchorable就像它名字所暗示的那样。可以被从他的容器窗格里拖走。然后重新放置在一个存在的窗格里。或者是放置在父DockingManager的边缘，或者是放置在一个浮动窗口里（LayoutAnchorableFloatingWindow）。
LayoutDocument 是一个仅可以被寄宿到LayoutDocumentPane的内容。它是一个特殊的内容，因为不能被停靠到边缘。仅能被放置到LayoutDocumentPane里。或者浮动在一个LayoutDocumentFloatingWindow窗口里。在途中，DocumentContent对象是program.cs&amp;rsquo; 或 &amp;lsquo;MainForm.cs&amp;rsquo; 文件视图
**LayoutFloatingWindow **，是一个包含内容的窗口，当被拖动到一个DockingManager上面的时候，LayoutFloatingWindow（LayoutAnchorableFloatingWindow和LayoutDocumentFloatingWindow继承自他）集成在Window，总是包含一个窗格（LayoutAnchorablePane或是LayoutDocumentPane），窗格包含更多的内容（LayoutAnchorable或LayoutDocument），当用户对一个内容或是DockablePane执行拖拽，或者直接手工使用代码调用LayoutContent.Float()方法 LayoutFloatingWindow就被直接从DockingManager创建出来了。
LayoutPane 一个基类，LayoutDockablePane和LayoutDocumentPane继承自它。它为他们提供了一些共有的属性和方法。
LayoutContent 是LayoutAnchorable 和LayoutAnchorable类的父类。提供了共有的属性和方法。
理解布局元素是一些属于布局模型的类而不是属于视图是很重要的。因为，他们不是继承自FrameworkElement类，取而代之。AvalonDock包含了另一些类来展示这些组件的视图。这些类通常被命名为相关联的类名+Control字串。举个例子，在布局里创建的LayoutAnchorable创建了一个LayoutAnchorableControl（继承自FrameworkElement的类），并且绑定了LayoutAnchorableControl.Model 到这个LayoutAnchorable对象上。
每一个被创建的视图控件总是有着Model属性的布局元素。因此，重新设计一个相关视图控件的样式是可以的。
为了开始创建一个新的.net 4/.net 4.5的解决方案。并且添加对AvalonDock.dll的引用（可以直接添加也可以使用NuGet），然后添加AD命名空间到MainWindow.xaml中。
在根Grid下放置DockingManager组件和一个简单的布局。
DockingManager是AvalonDock的核心类，他的责任就是创建管理布局。布局被定义成一个ILayoutElement的树。树的根由LayoutRoot类指定。LayoutRoot由一些基本的子树来构成。。
1.根面板的 根属性指向主 LayoutPanel，也是LayoutRoot的内容属性。
2.大体上讲，RightSide/LeftSide/TopSide/BottonSide是LayoutAnchorGroup对象的集合属性，他们表示了停靠管理器的四个边。停靠管理器的锚通常是隐藏的。当用户移动鼠标到这些区域的时候。就会在自动隐藏的窗口里显示出来。
3.FloatingWindows属性是FloatingWindow的集合。一个浮动窗口当用户拖动一个窗格（LayoutAnchorable或是LayoutDocument）的时候就被创建出来，这个集合可以被AvalonDock自动更新，但是用户依然可以通过调用LayoutContent的Float()方法来创建一个浮动窗口。
Hidden是一个Anchorable（停靠）对象的集合。默认情况下，当用户点击一个LayoutAnchorable对象的关闭按钮，AvalonDock隐藏它：通过从布局里移除停靠元素，并且把他放入Hidden集合，当用户想要再一次显示的时候，AD又把这个内容从隐藏集合里删除重新显示在他被隐藏的那个窗格里。
当使用布局树的时候，程序员可以创建任何复杂的界面，LayoutAnchorablePane的DockWidth和DockHeight属性可以被用来设置窗格的初始宽度和高度。而LayoutDocumentPane类通常则填满可用的空间。AvalonDock管理内容元素的宽度和高度以使得可以使用所有的可用空间。因此如果一个LayoutAnchorablePane被放置在一个LayoutPanel里，为LayoutAnchorablePane使用一个固定尺寸而为LayoutDocumentPane使用一个比例长度。也就是说为停靠对象使用了比例长度。
一个LayoutDocumentGroup/ LayoutAnchorableGroup类可以被用来包含更多的LayoutDocumentPane/ LayoutAnchorablePane，举个例子，让我们来改变上面的例子来实现更复杂的例子。
运行这个工程你就可以重新排列内容了。移动他们到浮动窗口。为了更加熟悉AvalonDock，我建议你多试几次，然后重新排列内容实现更复杂的布局。
在入门指南的第二部分。我将演示我们如何保存布局。附加事件像DocumentClose/ DocumentClosing 或者ActiveContent 改变的事件。 原文地址：AvalonDock 2.0 getting started guide PART 1 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>C#编写youtube下载器</title>
      <link>http://leaver.me/2012/09/25/c#%E7%BC%96%E5%86%99youtube%E4%B8%8B%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Tue, 25 Sep 2012 09:33:12 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/25/c#%E7%BC%96%E5%86%99youtube%E4%B8%8B%E8%BD%BD%E5%99%A8/</guid>
      <description>介绍 本文将会暂时如何仅仅使用C#来下载youtub视频，代码简单也容易理解，每个人都可以把它整合到自己的工程项目里。
我没有使用任何第三方的库来完成这段代码，你所要做的仅仅是把两个.cs文件整合进你的项目里。
使用代码 这个工程里有两个主要的类
YouTubeVideoQuality Class（youtube视频质量类）
YouTubeDownloader Class(youtube下载类)
有趣的地方 使用这个代码，你可以根据你的网速来选择不同品质的视频来下载
许多人网速很慢他们不能在线看youtube，因为我写了这个代码帮助这些人来下载视频到他们的PC上。这样，他们就能离线看了。。
许可 本文。包括源代码和文件，在CPOL下授权。
原文地址：YouTube-Downloader-Using-Csharp-NET 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>VS扩展故障,错误码:80131515</title>
      <link>http://leaver.me/2012/09/24/vs%E6%89%A9%E5%B1%95%E6%95%85%E9%9A%9C%E9%94%99%E8%AF%AF%E7%A0%8180131515/</link>
      <pubDate>Mon, 24 Sep 2012 08:04:33 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/24/vs%E6%89%A9%E5%B1%95%E6%95%85%E9%9A%9C%E9%94%99%E8%AF%AF%E7%A0%8180131515/</guid>
      <description>介绍 如果你给VS安装了Web Search扩展，如果第一次运行就出现了错误代码是80131515的问题。那么本文对你是有用的。。 
背景 当我远程试图运行Web Search的时候出现了这个错误。我用本文第一种方法解决了。。
解决方法 这个错误发生在当我远程以dll的方式调用的时候提示我说权限不够。。 为了解决这个问题，我们需要给devenv.exe.config文件添加loadFromRemoteSources 元素 首先使用管理员权限从下面的路径打开devenv.exe.config文件。 具体路径：你的VS安装目录\Common7\IDE\devenv.exe.config 并且添加loadFromRemoteSources 元素，并设为true。如下：
有时候windows会把下载的文件标记为“此文件来自一个不同的位置” ，然后对这些文件进行了很多的限制，这部分就是解锁下载的zip或是dll文件
为了解锁这些文件，只要右键点击这些文件，属性，选择常规，然后点击解锁按钮。如下图：  如果你还有其他的解决方法请告诉我哦。
许可 本文，包括源代码和文件，在CPOL下授权。
原文地址：Visual-Studio-Add-in-Troubleshooting-Error-Number 著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！</description>
    </item>
    
    <item>
      <title>.net显示网络连接状态图标</title>
      <link>http://leaver.me/2012/09/24/.net%E6%98%BE%E7%A4%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%9B%BE%E6%A0%87/</link>
      <pubDate>Mon, 24 Sep 2012 08:04:02 +0000</pubDate>
      
      <guid>http://leaver.me/2012/09/24/.net%E6%98%BE%E7%A4%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%9B%BE%E6%A0%87/</guid>
      <description>效果图： 
介绍 　越来越多的软件要通过连接互联网来执行一些业务层的业务操作，比如调用web services服务，获取数据等等。 通常你可能希望知道当前你的网络连接是不是真的连上了，当然有很多种方法可以做到，比如，你可以查看System.Net 命名空间中的NetworkInterface 的状态，但是有这以太网连接并不表示你的连接真的可以用。 本文将会展示一种方法，该方法在程序的状态栏StatusStrip 显示一个简单的图标来指示是不是真的连接到了互联网。
使用代码 　最简单的我们会想到使用一个Timer来进行http-get请求来判断一个特定的网页是否可用。
　当然这种方法下，我们最应该考虑的就是请求不能阻塞UI线程，因此，我将使用一个BackgroundWorker 对象来进行get请求，BackgroundWorker 对象声明了DoWork方法。该方法定义了一个事件句柄，该句柄传递一个DoWorkEventArgs 类来将事件的处理结果返回到UI线程，因此，你不必与任何的UI元素进行交互，因为它运行在一个独立的线程里。
　这个查询很简单，我执行简单的HttpWebRequest 来请求一个必然是可用的网页。比如微软的主页或是Google的主页。通过这样，我们就能知道是不是真的连接上了互联网。
　当BackgroundWorker 对象完成了他的工作，，也就是定义DoWork 里的事件，他会触发RunWorkerCompleted 事件，这个事件也定义了一个定制的事件句柄- RunWorkerCompletedEventArgs 有了这个类，我们就可以管理ToolStripStatusLabel的显示了
结论 　.net 是的使用后台线程很容易，也是的我们的UI有了更加平滑，有好的体验，现在，VS2005强烈建议手工为DoWork指定你的代理 ，因为VS.net有一个bug，当你尝试着重写而不是在另一个独立的线程里使用UI代码，VS可能会替换你写的代码。。 如果你需要使用Web Service，也许你可以考虑添加一个GetVersion的方法到你的Web Service里。然后尝试去访问这个服务。来确定你的web服务器是不是正常可用。
历史 　Demo version - 1.0.0.0 –随文附 许可本文没有显式的许可，但是可能包含了一些使用上的条款，不论是在文章里还是在下载的代码里。如果有疑问联系我吧。。
原文地址：Display an Internet Connection status icon using .NET Framework 2.0
著作权声明：本文由http://leaver.me 翻译，欢迎转载分享。请尊重作者劳动，转载时保留该声明和作者博客链接，谢谢！
源代码下载：InternetConnectionStatus</description>
    </item>
    
  </channel>
</rss>